#!/bin/bash
# Enhanced Framework for orchestrating multiple Cursor CLI agents with:
# - Self-validating QA loop
# - Agent coordination and communication
# - Dependency management
# - Shared state management

set -euo pipefail

# Configuration
AGENTS_DIR="${AGENTS_DIR:-/tmp/cursor-agents}"
LOG_DIR="${AGENTS_DIR}/logs"
PID_DIR="${AGENTS_DIR}/pids"
STATE_DIR="${AGENTS_DIR}/state"
QA_DIR="${AGENTS_DIR}/qa"
QA_WRAPPER="${QA_WRAPPER:-/home/ethan/qa-instructions/qa-wrapper.sh}"

# Create directories
mkdir -p "$AGENTS_DIR" "$LOG_DIR" "$PID_DIR" "$STATE_DIR" "$QA_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

usage() {
    cat << EOF
Enhanced Orchestrate Multiple Cursor Agents
With QA Validation and Agent Coordination

Usage: orchestrate-agents <command> [options]

Commands:
  start <task-file>        Start agents based on task configuration
  status                   Show status of all orchestrated agents
  stop <agent-id>          Stop a specific agent
  stop-all                 Stop all orchestrated agents
  logs <agent-id>          Show logs for a specific agent
  send <agent-id> <prompt> Send a prompt to a running agent
  qa <agent-id>            Run QA on agent's work directory
  wait <agent-id>          Wait for agent to complete and run QA
  monitor                  Monitor all agents and auto-run QA on completion
  state <agent-id>         Show agent's shared state
  set-state <agent-id> <key> <value>  Set shared state for coordination

Task File Format (JSON):
{
  "agents": [
    {
      "id": "agent1",
      "directory": "/path/to/project1",
      "initial_prompt": "Your task here",
      "model": "auto",             // Optional: Ignored - Cursor uses auto mode by default
      "dependencies": ["agent2"],  // Wait for these agents to complete
      "run_qa": true,              // Auto-run QA after completion
      "qa_required": true          // Fail if QA doesn't pass
    }
  ],
  "coordination": {
    "shared_vars": ["API_URL", "DATABASE_URL"],  // Variables to share
    "qa_on_completion": true                     // Auto-run QA for all
  }
}

Examples:
  # Start agents from config
  orchestrate-agents start tasks.json

  # Monitor and auto-run QA
  orchestrate-agents monitor

  # Check status
  orchestrate-agents status

  # Run QA on specific agent
  orchestrate-agents qa agent1

  # Set shared state for coordination
  orchestrate-agents set-state agent1 API_URL "http://localhost:3000"
EOF
}

# State management functions
get_agent_state() {
    local agent_id="$1"
    local state_file="${STATE_DIR}/${agent_id}.json"
    
    if [ -f "$state_file" ]; then
        cat "$state_file"
    else
        echo "{}"
    fi
}

set_agent_state() {
    local agent_id="$1"
    local key="$2"
    local value="$3"
    local state_file="${STATE_DIR}/${agent_id}.json"
    
    local current_state=$(get_agent_state "$agent_id")
    echo "$current_state" | jq --arg k "$key" --arg v "$value" '. + {($k): $v}' > "$state_file"
}

get_agent_status() {
    local agent_id="$1"
    local status_file="${STATE_DIR}/${agent_id}.status"
    
    if [ -f "$status_file" ]; then
        cat "$status_file"
    else
        echo "pending"
    fi
}

set_agent_status() {
    local agent_id="$1"
    local status="$2"
    echo "$status" > "${STATE_DIR}/${agent_id}.status"
}

# Check if agent dependencies are met
# Enhanced to allow non-critical dependency failures
check_dependencies() {
    local agent_id="$1"
    local task_file="$2"
    
    local deps=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .dependencies // [] | .[]" "$task_file" 2>/dev/null || echo "")
    
    if [ -z "$deps" ]; then
        return 0  # No dependencies
    fi
    
    for dep in $deps; do
        local dep_status=$(get_agent_status "$dep")
        
        # If dependency is completed or passed QA, it's met
        if [ "$dep_status" = "qa_passed" ] || [ "$dep_status" = "completed" ]; then
            continue
        fi
        
        # Check if dependency task is actually completed by checking tasks.json
        # This handles cases where agent status doesn't match task completion
        local project_id=$(basename "$(dirname "$(dirname "$task_file")")")
        local tasks_file="${HOME}/.auto-cursor/projects/${project_id}/tasks.json"
        if [ -f "$tasks_file" ]; then
            local task_status=$(jq -r ".[] | select(.id == \"$dep\") | .status" "$tasks_file" 2>/dev/null || echo "")
            if [ "$task_status" = "completed" ]; then
                # Task is completed in tasks.json - allow to proceed
                # Check QA severity if QA failed
                local qa_status=$(jq -r ".[] | select(.id == \"$dep\") | .qa_status" "$tasks_file" 2>/dev/null || echo "")
                if [ "$qa_status" = "failed" ]; then
                    # Check if failure is critical
                    local qa_log_file="${QA_DIR}/${dep}.log"
                    if [ -f "$qa_log_file" ]; then
                        # Check for critical failure indicators
                        if grep -qiE "(test failed|build failed|error:|exception|traceback|fatal)" "$qa_log_file" 2>/dev/null; then
                            # Critical failure - block this task
                            return 1
                        else
                            # Non-critical failure (docs, formatting, etc.) - allow task to proceed
                            continue
                        fi
                    else
                        # No QA log - assume non-critical and allow (since task completed)
                        continue
                    fi
                else
                    # QA passed or not run - allow
                    continue
                fi
            fi
        fi
        
        # If dependency failed, check if it's a critical failure
        if [ "$dep_status" = "qa_failed" ] || [ "$dep_status" = "failed" ]; then
            # Check QA log to determine if failure is critical
            local qa_log_file="${QA_DIR}/${dep}.log"
            if [ -f "$qa_log_file" ]; then
                # Check for critical failure indicators
                if grep -qiE "(test failed|build failed|error:|exception|traceback|fatal)" "$qa_log_file" 2>/dev/null; then
                    # Critical failure - block this task
                    return 1
                else
                    # Non-critical failure (docs, formatting, etc.) - allow task to proceed
                    continue
                fi
            else
                # No QA log - assume critical and block
                return 1
            fi
        else
            # Dependency not completed yet - block
            return 1
        fi
    done
    
    return 0  # All dependencies met (or non-critical failures)
}

# Run QA on agent's work
run_qa_for_agent() {
    local agent_id="$1"
    local task_file="$2"
    
    local directory=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .directory" "$task_file")
    local qa_required=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .qa_required // false" "$task_file")
    
    if [ ! -d "$directory" ]; then
        echo -e "${RED}Error: Directory does not exist: $directory${NC}" >&2
        set_agent_status "$agent_id" "qa_failed"
        return 1
    fi
    
    echo -e "${CYAN}Running QA for agent: $agent_id${NC}"
    echo "  Directory: $directory"
    
    set_agent_status "$agent_id" "qa_running"
    
    local qa_log="${QA_DIR}/${agent_id}.log"
    local qa_result=0
    
    if [ -f "$QA_WRAPPER" ]; then
        if bash "$QA_WRAPPER" "$directory" > "$qa_log" 2>&1; then
            qa_result=0
        else
            qa_result=$?
        fi
    else
        echo -e "${YELLOW}Warning: QA wrapper not found at $QA_WRAPPER${NC}"
        echo "Skipping QA validation..."
        set_agent_status "$agent_id" "qa_skipped"
        return 0
    fi
    
    if [ $qa_result -eq 0 ]; then
        echo -e "${GREEN}QA passed for agent: $agent_id${NC}"
        set_agent_status "$agent_id" "qa_passed"
        set_agent_state "$agent_id" "qa_timestamp" "$(date -Iseconds)"
        return 0
    else
        echo -e "${RED}QA failed for agent: $agent_id${NC}"
        echo "  Check QA log: $qa_log"
        set_agent_status "$agent_id" "qa_failed"
        
        if [ "$qa_required" = "true" ]; then
            echo -e "${RED}QA is required for $agent_id - marking as failed${NC}"
            return 1
        else
            echo -e "${YELLOW}QA failed but not required - continuing${NC}"
            return 0
        fi
    fi
}

# Wait for agent to complete and run QA
wait_for_agent() {
    local agent_id="$1"
    local task_file="$2"
    local timeout="${3:-3600}"  # Default 1 hour timeout
    local start_time=$(date +%s)
    
    echo -e "${CYAN}Waiting for agent: $agent_id${NC}"
    
    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        if [ $elapsed -gt $timeout ]; then
            echo -e "${RED}Timeout waiting for agent: $agent_id${NC}"
            return 1
        fi
        
        local pid_file="${PID_DIR}/${agent_id}.pid"
        if [ ! -f "$pid_file" ]; then
            # Agent never started
            sleep 2
            continue
        fi
        
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if [ -z "$pid" ] || [ "$pid" = "0" ]; then
            # Check if tmux session exists as fallback
            if tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
                # Still running in tmux
                sleep 5
                continue
            else
                # No PID and no tmux session - agent completed
                sleep 2
                continue
            fi
        fi
        
        # Check if process is still running
        if ! kill -0 "$pid" 2>/dev/null; then
            # Also check tmux session as fallback
            if ! tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
                # Agent completed
                echo -e "${GREEN}Agent $agent_id completed${NC}"
                
                local run_qa=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .run_qa // false" "$task_file")
                local qa_on_completion=$(jq -r ".coordination.qa_on_completion // false" "$task_file")
                
                if [ "$run_qa" = "true" ] || [ "$qa_on_completion" = "true" ]; then
                    run_qa_for_agent "$agent_id" "$task_file"
                else
                    set_agent_status "$agent_id" "completed"
                fi
                
                return 0
            fi
        fi
        
        sleep 5
    done
}

start_agent() {
    local agent_id="$1"
    local directory="$2"
    local prompt="$3"
    local task_file="$4"
    # Note: Cursor CLI uses auto mode by default, model parameter is ignored
    
    if [ ! -d "$directory" ]; then
        echo -e "${RED}Error: Directory does not exist: $directory${NC}" >&2
        return 1
    fi
    
    # Check dependencies
    if ! check_dependencies "$agent_id" "$task_file"; then
        echo -e "${YELLOW}Agent $agent_id waiting for dependencies...${NC}"
        set_agent_status "$agent_id" "waiting"
        return 2  # Special return code for dependencies
    fi
    
    local pid_file="${PID_DIR}/${agent_id}.pid"
    local log_file="${LOG_DIR}/${agent_id}.log"
    
    if [ -f "$pid_file" ]; then
        local old_pid=$(cat "$pid_file")
        if kill -0 "$old_pid" 2>/dev/null; then
            echo -e "${YELLOW}Agent $agent_id is already running (PID: $old_pid)${NC}"
            return 0
        fi
    fi
    
    echo -e "${GREEN}Starting agent: $agent_id${NC}"
    echo "  Directory: $directory"
    echo "  Prompt: ${prompt:0:50}..."
    echo "  Mode: auto (Cursor default)"
    
    set_agent_status "$agent_id" "running"
    
    # Start agent in background
    # Note: cursor-agent accepts prompt as argument, not via stdin
    # Use --print flag to prevent opening GUI and run in CLI-only mode
    # Create a wrapper script to properly handle the prompt
    # Use cursor-agent directly (CLI binary) instead of cursor agent (GUI wrapper)
    local wrapper_script="${AGENTS_DIR}/wrapper-${agent_id}.sh"
    local pause_file="${directory}/PAUSE"
    local human_input_file="${directory}/HUMAN_INPUT.md"
    
    cat > "$wrapper_script" << 'WRAPPER_EOF'
#!/bin/bash
set -euo pipefail

AGENT_DIR="$1"
AGENT_PROMPT="$2"
LOG_FILE="$3"
PAUSE_FILE="${AGENT_DIR}/PAUSE"
HUMAN_INPUT_FILE="${AGENT_DIR}/HUMAN_INPUT.md"

cd "$AGENT_DIR"

# Function to check for pause
check_pause() {
    if [ -f "$PAUSE_FILE" ]; then
        echo "  PAUSED BY HUMAN" >> "$LOG_FILE"
        echo "  Pause file detected: $PAUSE_FILE" >> "$LOG_FILE"
        echo "  Waiting for pause file to be removed..." >> "$LOG_FILE"
        
        while [ -f "$PAUSE_FILE" ]; do
            sleep 5
        done
        
        echo "  Resume detected - continuing..." >> "$LOG_FILE"
    fi
}

# Function to read human input
read_human_input() {
    if [ -f "$HUMAN_INPUT_FILE" ]; then
        echo "  Reading HUMAN_INPUT.md..." >> "$LOG_FILE"
        local human_input=$(cat "$HUMAN_INPUT_FILE")
        if [ -n "$human_input" ]; then
            AGENT_PROMPT="${AGENT_PROMPT}

HUMAN INPUT/INSTRUCTIONS:
${human_input}

Please incorporate these instructions into your work."
            echo "  Human input incorporated into prompt" >> "$LOG_FILE"
        fi
    fi
}

# Check for pause before starting
check_pause

# Read human input before starting
read_human_input

# Run agent with the prompt
exec cursor-agent --print "$AGENT_PROMPT" 2>&1 | tee "$LOG_FILE"
WRAPPER_EOF
    
    chmod +x "$wrapper_script"
    
    # Pass directory, prompt, and log file as arguments
    local wrapper_call="$wrapper_script \"$directory\" \"$prompt\" \"$log_file\""
    
    (
        # Use tmux for better session management
        if command -v tmux >/dev/null 2>&1; then
            # Use --print flag to prevent GUI from opening, run in CLI-only mode
            tmux new-session -d -s "cursor-agent-${agent_id}" \
                bash -c "$wrapper_call"
            sleep 3
            # Get the PID from tmux - try multiple methods
            local pid=""
            # Method 1: Get PID from tmux pane
            pid=$(tmux list-panes -t "cursor-agent-${agent_id}" -F '#{pane_pid}' 2>/dev/null | head -1 || echo "")
            
            # Method 2: Look for cursor-agent process in the directory
            if [ -z "$pid" ]; then
                pid=$(pgrep -f "cursor.*agent.*--print" | head -1 || echo "")
            fi
            
            # Method 3: Look for any cursor process in the directory (fallback)
            if [ -z "$pid" ]; then
                # Wait a bit more and check process tree
                sleep 2
                pid=$(ps aux | grep -E "cursor.*agent" | grep -v grep | grep "$directory" | awk '{print $2}' | head -1 || echo "")
            fi
            
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                echo "$pid" > "$pid_file"
                echo -e "${GREEN}Agent $agent_id started (PID: $pid)${NC}"
            else
                echo -e "${YELLOW}Warning: Could not determine PID for agent $agent_id${NC}" >&2
                echo -e "${YELLOW}Agent may still be starting. Check logs: $log_file${NC}" >&2
                echo -e "${YELLOW}You can check status with: orchestrate-agents status${NC}" >&2
                # Still create a placeholder PID file so status command works
                echo "0" > "$pid_file"
            fi
        else
            # Fallback: use nohup with wrapper script
            nohup bash -c "$wrapper_call" > "$log_file" 2>&1 &
            local bg_pid=$!
            echo "$bg_pid" > "$pid_file"
            echo -e "${GREEN}Agent $agent_id started (PID: $bg_pid)${NC}"
        fi
    )
}

start_from_config() {
    local task_file="$1"
    
    if [ ! -f "$task_file" ]; then
        echo -e "${RED}Error: Task file not found: $task_file${NC}" >&2
        exit 1
    fi
    
    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${RED}Error: jq is required for JSON parsing. Install with: sudo apt-get install jq${NC}" >&2
        exit 1
    fi
    
    local agent_count=$(jq '.agents | length' "$task_file")
    echo -e "${GREEN}Starting $agent_count agents from $task_file${NC}"
    echo ""
    
    # Initialize all agent states
    for i in $(seq 0 $((agent_count - 1))); do
        local agent_id=$(jq -r ".agents[$i].id" "$task_file")
        set_agent_status "$agent_id" "pending"
        echo "{}" > "${STATE_DIR}/${agent_id}.json"
    done
    
    # Start agents (may need multiple passes for dependencies)
    local max_iterations=10
    local iteration=0
    
    while [ $iteration -lt $max_iterations ]; do
        local started_any=false
        
        for i in $(seq 0 $((agent_count - 1))); do
            local agent_id=$(jq -r ".agents[$i].id" "$task_file")
            local status=$(get_agent_status "$agent_id")
            
            if [ "$status" = "pending" ] || [ "$status" = "waiting" ]; then
                local directory=$(jq -r ".agents[$i].directory" "$task_file")
                local prompt=$(jq -r ".agents[$i].initial_prompt" "$task_file")
                
                if start_agent "$agent_id" "$directory" "$prompt" "$task_file"; then
                    started_any=true
                elif [ $? -eq 2 ]; then
                    # Waiting for dependencies
                    started_any=true  # Still made progress
                fi
                echo ""
            fi
        done
        
        if [ "$started_any" = "false" ]; then
            break  # All agents started or waiting
        fi
        
        iteration=$((iteration + 1))
        sleep 2
    done
    
    echo -e "${GREEN}Agent startup complete. Use 'orchestrate-agents status' to check their status.${NC}"
    echo -e "${CYAN}Use 'orchestrate-agents monitor' to auto-run QA on completion.${NC}"
}

show_status() {
    echo "=== Enhanced Orchestrated Agents Status ==="
    echo ""
    
    if [ ! -d "$PID_DIR" ] || [ -z "$(ls -A $PID_DIR 2>/dev/null)" ]; then
        echo "No agents currently running."
        return
    fi
    
    for pid_file in "$PID_DIR"/*.pid; do
        [ -f "$pid_file" ] || continue
        
        local agent_id=$(basename "$pid_file" .pid)
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        local log_file="${LOG_DIR}/${agent_id}.log"
        local status=$(get_agent_status "$agent_id")
        
        # Color code status
        case "$status" in
            pending|waiting)
                local status_color="${YELLOW}"
                ;;
            running)
                local status_color="${BLUE}"
                ;;
            completed|qa_passed)
                local status_color="${GREEN}"
                ;;
            qa_failed|failed)
                local status_color="${RED}"
                ;;
            qa_running)
                local status_color="${CYAN}"
                ;;
            *)
                local status_color="${NC}"
                ;;
        esac
        
        echo -e "${status_color}$agent_id: $status${NC}"
        
        # Check if agent is actually running (handle placeholder PID 0)
        if [ -n "$pid" ] && [ "$pid" != "0" ] && kill -0 "$pid" 2>/dev/null; then
            echo "  PID: $pid (Running)"
        elif [ "$pid" = "0" ]; then
            # Check if tmux session exists as fallback
            if tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
                echo "  Status: Running (tmux session active)"
            elif [ "$status" = "running" ]; then
                echo "  Status: Running (PID detection failed, check logs)"
            fi
        elif [ "$status" = "qa_passed" ] || [ "$status" = "completed" ]; then
            echo "  Status: Completed"
        elif [ "$status" = "qa_failed" ]; then
            echo "  Status: QA Failed - Check ${QA_DIR}/${agent_id}.log"
        fi
        
        if [ -f "$log_file" ]; then
            local log_size=$(du -h "$log_file" 2>/dev/null | cut -f1 || echo "?")
            local last_line=$(tail -1 "$log_file" 2>/dev/null | cut -c1-80 || echo "")
            echo "  Log: $log_file ($log_size)"
            if [ -n "$last_line" ]; then
                echo "  Last: ${last_line}..."
            fi
        fi
        
        # Show shared state
        local state_file="${STATE_DIR}/${agent_id}.json"
        if [ -f "$state_file" ] && [ -s "$state_file" ]; then
            local state_keys=$(jq -r 'keys[]' "$state_file" 2>/dev/null | head -3)
            if [ -n "$state_keys" ]; then
                echo "  State: $(echo "$state_keys" | tr '\n' ', ' | sed 's/,$//')"
            fi
        fi
        
        echo ""
    done
}

monitor_agents() {
    local task_file="${1:-}"
    
    if [ -z "$task_file" ] || [ ! -f "$task_file" ]; then
        echo -e "${RED}Error: Task file required for monitoring${NC}" >&2
        echo "Usage: orchestrate-agents monitor <task-file>"
        exit 1
    fi
    
    echo -e "${CYAN}Monitoring agents and auto-running QA on completion...${NC}"
    echo "Press Ctrl+C to stop monitoring"
    echo ""
    
    while true; do
        local agent_count=$(jq '.agents | length' "$task_file")
        local all_done=true
        
        for i in $(seq 0 $((agent_count - 1))); do
            local agent_id=$(jq -r ".agents[$i].id" "$task_file")
            local status=$(get_agent_status "$agent_id")
            local pid_file="${PID_DIR}/${agent_id}.pid"
            
            # Check if agent just completed
            if [ "$status" = "running" ]; then
                if [ -f "$pid_file" ]; then
                    local pid=$(cat "$pid_file" 2>/dev/null || echo "")
                    local process_running=false
                    local tmux_running=false
                    
                    # Check if process is running
                    if [ -n "$pid" ] && [ "$pid" != "0" ] && kill -0 "$pid" 2>/dev/null; then
                        process_running=true
                    fi
                    
                    # Check if tmux session exists
                    if tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
                        tmux_running=true
                    fi
                    
                    if [ "$process_running" = "false" ] && [ "$tmux_running" = "false" ]; then
                        # Agent just finished
                        echo -e "${GREEN}Agent $agent_id just completed!${NC}"
                        
                        local run_qa=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .run_qa // false" "$task_file")
                        local qa_on_completion=$(jq -r ".coordination.qa_on_completion // false" "$task_file")
                        
                        if [ "$run_qa" = "true" ] || [ "$qa_on_completion" = "true" ]; then
                            run_qa_for_agent "$agent_id" "$task_file"
                            # Update task status in Auto-Cursor tasks.json if it exists
                            local project_dir=$(dirname "$task_file" 2>/dev/null || echo "")
                            if [ -n "$project_dir" ] && [ -f "${project_dir}/tasks.json" ]; then
                                local tasks_file="${project_dir}/tasks.json"
                                local qa_status=$(get_agent_status "$agent_id")
                                if [ "$qa_status" = "qa_passed" ] || [ "$qa_status" = "qa_failed" ]; then
                                    local updated_tasks=$(cat "$tasks_file" | jq "map(if .id == \"$agent_id\" then .status = \"$qa_status\" | .qa_status = \"$qa_status\" | .completed = now else . end)")
                                    echo "$updated_tasks" | jq '.' > "$tasks_file"
                                fi
                            fi
                        else
                            set_agent_status "$agent_id" "completed"
                            # Update task status in Auto-Cursor tasks.json if it exists
                            local project_dir=$(dirname "$task_file" 2>/dev/null || echo "")
                            if [ -n "$project_dir" ] && [ -f "${project_dir}/tasks.json" ]; then
                                local tasks_file="${project_dir}/tasks.json"
                                local updated_tasks=$(cat "$tasks_file" | jq "map(if .id == \"$agent_id\" then .status = \"completed\" | .completed = now else . end)")
                                echo "$updated_tasks" | jq '.' > "$tasks_file"
                            fi
                        fi
                    fi
                fi
            fi
            
            # Check for waiting agents that can now start
            if [ "$status" = "waiting" ]; then
                if check_dependencies "$agent_id" "$task_file"; then
                    local directory=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .directory" "$task_file")
                    local prompt=$(jq -r ".agents[] | select(.id == \"$agent_id\") | .initial_prompt" "$task_file")
                    
                    echo -e "${GREEN}Dependencies met for $agent_id, starting...${NC}"
                    start_agent "$agent_id" "$directory" "$prompt" "$task_file"
                fi
            fi
            
            # Check if still processing
            if [ "$status" != "qa_passed" ] && [ "$status" != "completed" ] && [ "$status" != "qa_failed" ]; then
                all_done=false
            fi
        done
        
        if [ "$all_done" = "true" ]; then
            echo -e "${GREEN}All agents completed!${NC}"
            break
        fi
        
        sleep 5
    done
}

stop_agent() {
    local agent_id="$1"
    local pid_file="${PID_DIR}/${agent_id}.pid"
    local wrapper_script="${AGENTS_DIR}/wrapper-${agent_id}.sh"
    
    if [ ! -f "$pid_file" ]; then
        echo -e "${YELLOW}Warning: PID file not found for agent $agent_id${NC}" >&2
        # Still try to stop tmux session if it exists
        if tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
            echo "Stopping tmux session: cursor-agent-${agent_id}"
            tmux kill-session -t "cursor-agent-${agent_id}" 2>/dev/null || true
            echo -e "${GREEN}Stopped agent $agent_id (tmux session)${NC}"
            set_agent_status "$agent_id" "stopped"
        else
            echo -e "${RED}Error: Agent $agent_id not found${NC}" >&2
            exit 1
        fi
        return
    fi
    
    local pid=$(cat "$pid_file")
    
    # Try tmux first (most reliable)
    if tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
        echo "Stopping tmux session: cursor-agent-${agent_id}"
        tmux kill-session -t "cursor-agent-${agent_id}" 2>/dev/null || true
    fi
    
    # Kill the process if it's still running
    if [ -n "$pid" ] && [ "$pid" != "0" ] && kill -0 "$pid" 2>/dev/null; then
        kill "$pid" 2>/dev/null || true
        echo -e "${GREEN}Stopped agent $agent_id (PID: $pid)${NC}"
    else
        echo -e "${YELLOW}Process $pid not found (may have already exited)${NC}"
    fi
    
    # Cleanup
    rm -f "$pid_file"
    rm -f "$wrapper_script"
    set_agent_status "$agent_id" "stopped"
}

stop_all() {
    echo "Stopping all orchestrated agents..."
    
    if [ ! -d "$PID_DIR" ]; then
        echo "No agents directory found."
        return
    fi
    
    for pid_file in "$PID_DIR"/*.pid; do
        if [ -f "$pid_file" ]; then
            local agent_id=$(basename "$pid_file" .pid)
            stop_agent "$agent_id"
        fi
    done
    
    echo -e "${GREEN}All agents stopped.${NC}"
}

show_logs() {
    local agent_id="$1"
    local log_file="${LOG_DIR}/${agent_id}.log"
    
    if [ ! -f "$log_file" ]; then
        echo -e "${RED}Error: Log file not found for agent $agent_id${NC}" >&2
        exit 1
    fi
    
    echo "=== Logs for $agent_id ==="
    echo ""
    tail -f "$log_file"
}

send_prompt() {
    local agent_id="$1"
    shift
    local prompt="$*"
    
    echo -e "${YELLOW}Sending prompt to agent $agent_id...${NC}"
    
    # Try to send via tmux if available
    if tmux has-session -t "cursor-agent-${agent_id}" 2>/dev/null; then
        tmux send-keys -t "cursor-agent-${agent_id}" "$prompt" Enter
        echo -e "${GREEN}Prompt sent${NC}"
    else
        echo -e "${RED}Error: Agent $agent_id not found in tmux sessions${NC}" >&2
        echo "Note: Prompt sending only works with tmux-managed agents"
        exit 1
    fi
}

show_agent_state() {
    local agent_id="$1"
    local state_file="${STATE_DIR}/${agent_id}.json"
    
    if [ ! -f "$state_file" ]; then
        echo -e "${RED}Error: State file not found for agent $agent_id${NC}" >&2
        exit 1
    fi
    
    echo "=== Shared State for $agent_id ==="
    echo ""
    cat "$state_file" | jq '.' 2>/dev/null || cat "$state_file"
}

# Main command dispatch
case "${1:-help}" in
    start)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Task file required${NC}" >&2
            usage
            exit 1
        fi
        start_from_config "$2"
        ;;
    status)
        show_status
        ;;
    stop)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Agent ID required${NC}" >&2
            usage
            exit 1
        fi
        stop_agent "$2"
        ;;
    stop-all)
        stop_all
        ;;
    logs)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Agent ID required${NC}" >&2
            usage
            exit 1
        fi
        show_logs "$2"
        ;;
    send)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Agent ID and prompt required${NC}" >&2
            usage
            exit 1
        fi
        send_prompt "$2" "${@:3}"
        ;;
    qa)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Agent ID required${NC}" >&2
            usage
            exit 1
        fi
        if [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Task file required${NC}" >&2
            usage
            exit 1
        fi
        run_qa_for_agent "$2" "$3"
        ;;
    wait)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Agent ID required${NC}" >&2
            usage
            exit 1
        fi
        if [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Task file required${NC}" >&2
            usage
            exit 1
        fi
        wait_for_agent "$2" "$3" "${4:-3600}"
        ;;
    monitor)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Task file required${NC}" >&2
            usage
            exit 1
        fi
        monitor_agents "$2"
        ;;
    state)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Agent ID required${NC}" >&2
            usage
            exit 1
        fi
        show_agent_state "$2"
        ;;
    set-state)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ] || [ -z "${4:-}" ]; then
            echo -e "${RED}Error: Agent ID, key, and value required${NC}" >&2
            usage
            exit 1
        fi
        set_agent_state "$2" "$3" "$4"
        echo -e "${GREEN}State set: $2.$3 = $4${NC}"
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}" >&2
        echo ""
        usage
        exit 1
        ;;
esac
