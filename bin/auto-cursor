#!/bin/bash
# Auto-Cursor: Autonomous multi-agent coding framework
# Similar to Auto-Claude but using Cursor CLI agents
# Plans, builds, and validates software autonomously

set -euo pipefail

# Version
VERSION="10.0.1"

# Configuration
AUTO_CURSOR_DIR="${AUTO_CURSOR_DIR:-$HOME/.auto-cursor}"
PROJECTS_DIR="${AUTO_CURSOR_DIR}/projects"
MEMORY_DIR="${AUTO_CURSOR_DIR}/memory"
WORKTREES_DIR="${AUTO_CURSOR_DIR}/worktrees"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Create directories
mkdir -p "$AUTO_CURSOR_DIR" "$PROJECTS_DIR" "$MEMORY_DIR" "$WORKTREES_DIR"

# Command Registry (Single Source of Truth)
# Format: "command:description:min_args:max_args:flags"
declare -A COMMAND_REGISTRY=(
    ["init"]="Initialize a new project:1:2:"
    ["plan"]="Create a plan for a goal:2:999:--interactive --complexity"
    ["start"]="Start executing the current plan:1:1:--parallel"
    ["status"]="Show kanban board status:1:1:--detailed"
    ["board"]="Interactive kanban board:1:1:"
    ["tasks"]="List all tasks with details:1:1:"
    ["validate"]="Validate plan structure and dependencies:1:1:--auto-fix"
    ["plan-review"]="Review generated plan:1:1:"
    ["plan-edit"]="Edit plan interactively:1:1:"
    ["task-add"]="Add custom task to plan:2:999:"
    ["task-remove"]="Remove task from plan:2:2:"
    ["task-modify"]="Modify task in plan:2:2:"
    ["pause"]="Pause specific task:2:2:"
    ["cancel"]="Cancel specific task:2:2:"
    ["agent"]="Show agent working on task:2:2:"
    ["logs"]="View agent logs (use 'all' for all tasks):1:2:--tail"
    ["retry"]="Retry failed task (use 'all' for all failed):1:2:"
    ["diff"]="Show diff before merge:2:2:"
    ["merge"]="Merge worktree back to main (use 'all' for all tasks):1:2:"
    ["review"]="Review changes in worktree (use 'all' for all):1:2:"
    ["discard"]="Discard worktree without merging:1:2:"
    ["run"]="Golden-path: init → plan → validate → start → review → merge → summary:2:3:"
    ["website"]="One-shot website builder: converts business brief to spec and runs golden-path:2:3:--parallel"
    ["trace-summary"]="Show execution trace summary with concurrency analysis:1:1:"
    ["progress"]="Show live progress view for a project:1:1:"
    ["upgrade-check"]="Check for updates and show changelog:0:0:"
    ["continue"]="Continue interrupted execution:1:1:"
    ["summary"]="Show run summary with per-task results:1:1:"
    ["migrate"]="Migrate project state to current version:1:1:"
    ["cleanup"]="Clean up terminal-state worktrees for a project:1:1:"
    ["contracts"]="Check contract enforcement:1:1:"
    ["memory"]="View memory/insights:1:1:"
    ["list"]="List all projects:0:0:"
    ["clean"]="Clean up worktrees and agents (only project agents):1:1:"
    ["doctor"]="Check system health and dependencies:0:0:"
    ["version"]="Show version:0:0:"
    ["help"]="Show this help message:0:0:"
)

# Blocked flags (violate safety guarantees)
BLOCKED_FLAGS=("--skip-qa" "--max-iterations")

check_blocked_flag() {
    local flag="$1"
    for blocked in "${BLOCKED_FLAGS[@]}"; do
        if [ "$flag" = "$blocked" ]; then
            echo -e "${RED}Error: Flag $flag is not supported in v1.0.0 due to safety guarantees.${NC}" >&2
            echo -e "${YELLOW}This flag would bypass verification gates and is not allowed.${NC}" >&2
            exit 1
        fi
    done
}

usage() {
    cat << EOF
Auto-Cursor: Autonomous Multi-Agent Coding Framework
Version: $VERSION

Usage: auto-cursor <command> [options]

Commands:
EOF
    
    # Generate help from registry
    for cmd in $(printf '%s\n' "${!COMMAND_REGISTRY[@]}" | sort); do
        local entry="${COMMAND_REGISTRY[$cmd]}"
        local desc=$(echo "$entry" | cut -d: -f1)
        local flags=$(echo "$entry" | cut -d: -f5)
        
        printf "  %-20s %s\n" "$cmd" "$desc"
        
        if [ -n "$flags" ]; then
            for flag in $flags; do
                case "$flag" in
                    --interactive)
                        echo "    --interactive              Interactive goal refinement"
                        ;;
                    --complexity)
                        echo "    --complexity <level>       Override complexity (simple/medium/complex)"
                        ;;
                    --parallel)
                        echo "    --parallel <n>             Max concurrent tasks (default: 3)"
                        ;;
                    --detailed)
                        echo "    --detailed                 Show detailed progress with time estimates"
                        ;;
                    --auto-fix)
                        echo "    --auto-fix                 Auto-fix common issues"
                        ;;
                    --tail)
                        echo "    --tail                     Stream logs with task prefixes"
                        ;;
                esac
            done
        fi
    done
    
    cat << EOF

Examples:
  # Quick start (golden path)
  auto-cursor run ~/my-project "Build a marketing website"

  # Check system health
  auto-cursor doctor

  # Initialize and plan manually
  auto-cursor init ~/my-project my-project
  auto-cursor plan my-project "Add user authentication"

  # Start execution
  auto-cursor start my-project --parallel 3

  # View status and summary
  auto-cursor status my-project
  auto-cursor summary my-project

  # Check contracts
  auto-cursor contracts my-project
EOF
}

# Project management
init_project() {
    local project_path="$1"
    local project_id="${2:-$(basename "$project_path")}"
    
    if [ ! -d "$project_path" ]; then
        echo -e "${RED}Error: Project path does not exist: $project_path${NC}" >&2
        exit 1
    fi
    
    # Check if it's a git repo
    if [ ! -d "$project_path/.git" ]; then
        echo -e "${YELLOW}Initializing git repository...${NC}"
        (cd "$project_path" && git init)
    fi
    
    local project_dir="${PROJECTS_DIR}/${project_id}"
    mkdir -p "$project_dir"
    
    # Create project config with state version
    cat > "${project_dir}/config.json" << EOF
{
  "id": "$project_id",
  "path": "$project_path",
  "created": "$(date -Iseconds)",
  "status": "active",
  "state_version": "7.0"
}
EOF
    
    # Initialize plan
    echo "[]" > "${project_dir}/plan.json"
    echo "[]" > "${project_dir}/tasks.json"
    echo "{}" > "${project_dir}/memory.json"
    
    echo -e "${GREEN}Project initialized: $project_id${NC}"
    echo "  Path: $project_path"
    echo "  Config: ${project_dir}/config.json"
}

# Task planning
plan_goal() {
    local project_id="$1"
    shift
    
    # Parse flags
    local goal=""
    local complexity=""
    local interactive=false
    
    while [ $# -gt 0 ]; do
        case "$1" in
            --complexity)
                complexity="$2"
                shift 2
                ;;
            --interactive)
                interactive=true
                shift
                ;;
            *)
                if [ -z "$goal" ]; then
                    goal="$1"
                else
                    goal="$goal $1"
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$goal" ] && [ "$interactive" = "false" ]; then
        echo -e "${RED}Error: Goal required (or use --interactive)${NC}" >&2
        exit 1
    fi
    
    local project_dir="${PROJECTS_DIR}/${project_id}"
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    
    # Interactive mode
    if [ "$interactive" = "true" ]; then
        plan_goal_interactive "$project_id" "$project_path" "$complexity"
        return
    fi
    
    echo -e "${CYAN}Planning goal: $goal${NC}"
    if [ -n "$complexity" ]; then
        echo -e "${YELLOW}Complexity override: $complexity${NC}"
    fi
    echo ""
    
    # Use enhanced planner with complexity override and memory
    local memory_file="${project_dir}/memory.json"
    echo -e "${BLUE}Generating plan with AI...${NC}"
    if [ -f "$memory_file" ] && [ -s "$memory_file" ] && [ "$(cat "$memory_file" | jq 'keys | length' 2>/dev/null || echo "0")" != "0" ]; then
        echo -e "${CYAN}Using memory insights from past builds...${NC}"
    fi
    local plan_json=$(auto-cursor-planner "$goal" "$project_path" "$complexity" "$memory_file")
    
    # Save plan
    echo "$plan_json" | jq '.' > "${project_dir}/plan.json"
    
    # Save plan output for debugging
    echo "$plan_json" | jq '.' > "${project_dir}/plan-output.json"
    
    # Convert plan to tasks with status and lifecycle fields
    local tasks_json=$(echo "$plan_json" | jq 'map(. + {
      "status": "pending",
      "agent_id": null,
      "worktree": null,
      "created": now,
      "started": null,
      "completed": null,
      "qa_status": null,
      "verify_commands": (.verify_commands // []),
      "retry_count": 0,
      "max_retries": 3,
      "logs_path": null,
      "last_qa_run": null,
      "last_qa_result": null,
      "owner_role": (.owner_role // "frontend"),
      "owned_paths": (.owned_paths // [.directory]),
      "boundaries": (.boundaries // "do not edit outside owned_paths")
    })')
    
    echo "$tasks_json" | jq '.' > "${project_dir}/tasks.json"
    
    local task_count=$(echo "$tasks_json" | jq 'length' 2>/dev/null || echo "0")
    if [ -z "$task_count" ] || [ "$task_count" = "null" ]; then
        task_count="0"
    fi
    echo -e "${GREEN}Plan created with $task_count tasks${NC}"
    
    # Try to save memory (will only save if there's existing successful history)
    save_plan_to_memory "$project_id" 2>/dev/null || true
    
    echo ""
    
    # Validate plan
    local validation_errors=$(echo "$tasks_json" | jq -r '
        . as $tasks |
        [
            (if (map(.id) | unique | length) != length then "Duplicate task IDs found" else empty end),
            (if (map(.id) | map(select(. == null or . == ""))) | length > 0 then "Missing task IDs" else empty end),
            (if (map(.description) | map(select(. == null or . == ""))) | length > 0 then "Missing descriptions" else empty end)
        ] | .[] | select(. != null)
    ' 2>/dev/null || echo "")
    
    if [ -n "$validation_errors" ]; then
        echo -e "${YELLOW}Validation warnings:${NC}"
        echo "$validation_errors" | while read -r error; do
            [ -n "$error" ] && echo "  ⚠️  $error"
        done
        echo ""
    fi
    
    echo "$tasks_json" | jq -r '.[] | "  - \(.id): \(.description)"'
    
    # Show progress estimate
    local total_hours=$(echo "$tasks_json" | jq '[.[] | .estimated_hours // 0] | add' 2>/dev/null || echo "0")
    if [ "$total_hours" != "0" ] && [ -n "$total_hours" ] && [ "$total_hours" != "null" ]; then
        echo ""
        echo -e "${CYAN}Estimated total time: ${total_hours} hours${NC}"
    fi
}

# Interactive planning mode
plan_goal_interactive() {
    local project_id="$1"
    local project_path="$2"
    local complexity_override="${3:-}"
    
    echo -e "${CYAN}=== Interactive Planning Mode ===${NC}"
    echo ""
    echo "Let's refine your goal step by step."
    echo ""
    
    # Step 1: Get initial goal
    echo -e "${BLUE}Step 1: What do you want to build?${NC}"
    read -p "Goal: " goal
    
    if [ -z "$goal" ]; then
        echo -e "${RED}Error: Goal cannot be empty${NC}" >&2
        exit 1
    fi
    
    # Step 2: Refine goal with AI
    echo ""
    echo -e "${BLUE}Step 2: Refining goal with AI...${NC}"
    local refinement_prompt="The user wants to: $goal

Please help refine this goal by:
1. Asking clarifying questions
2. Identifying potential ambiguities
3. Suggesting improvements

Respond with:
- Refined goal (if improvements found)
- OR confirmation that the goal is clear
- Any questions or concerns"
    
    local temp_refine=$(mktemp)
    local adapter="${BASH_SOURCE[0]%/*}/cursor-agent-adapter"
    if [ ! -f "$adapter" ]; then
        adapter="cursor-agent"
    fi
    
    (
        cd "$project_path"
        "$adapter" --print "$refinement_prompt" > "$temp_refine" 2>&1 || true
    )
    
    local refined_output=$(cat "$temp_refine" | grep -v "^\[" | head -20)
    echo ""
    echo -e "${GREEN}AI Refinement:${NC}"
    echo "$refined_output"
    echo ""
    
    # Step 3: Confirm or edit
    read -p "Use this refined goal? (y/n/edit): " confirm
    case "$confirm" in
        edit|e)
            echo ""
            read -p "Enter your refined goal: " goal
            ;;
        n|no)
            echo -e "${YELLOW}Cancelled${NC}"
            exit 0
            ;;
        *)
            # Use original goal
            ;;
    esac
    
    # Step 4: Complexity (if not overridden)
    if [ -z "$complexity_override" ]; then
        echo ""
        echo -e "${BLUE}Step 3: Complexity Level${NC}"
        echo "  simple   - 1-2 files, single service, no integrations"
        echo "  medium   - 3-10 files, 1-2 services, minimal integrations"
        echo "  complex  - 10+ files, multiple services, external integrations"
        echo ""
        read -p "Complexity (simple/medium/complex/auto): " complexity_override
        if [ "$complexity_override" = "auto" ] || [ -z "$complexity_override" ]; then
            complexity_override=""
        fi
    fi
    
    # Step 5: Generate plan
    echo ""
    echo -e "${BLUE}Step 4: Generating plan...${NC}"
    rm -f "$temp_refine"
    
    # Call regular plan_goal with the refined goal
    plan_goal "$project_id" "$goal" ${complexity_override:+--complexity "$complexity_override"}
}

# Start execution
start_execution() {
    local project_id="$1"
    local max_iterations="${2:-}"
    local skip_qa="${3:-false}"
    local parallel="${4:-3}"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    local tasks_file="${project_dir}/tasks.json"
    
    # Warn if validate hasn't been run
    if [ -f "$tasks_file" ]; then
        local validated=$(jq -r '.[0].validated // false' "$tasks_file" 2>/dev/null || echo "false")
        if [ "$validated" != "true" ]; then
            echo -e "${YELLOW}⚠ Warning: Plan has not been validated. Run 'auto-cursor validate $project_id' first.${NC}"
        fi
    fi
    
    # Load tasks
    local tasks=$(cat "$tasks_file")
    local pending_tasks=$(echo "$tasks" | jq '[.[] | select(.status == "pending")]')
    
    if [ "$(echo "$pending_tasks" | jq 'length')" -eq 0 ]; then
        echo -e "${YELLOW}No pending tasks to execute${NC}"
        return
    fi
    
    echo -e "${CYAN}Starting execution...${NC}"
    echo ""
    
    # Create orchestration config
    local orchestration_file="${project_dir}/orchestration.json"
    local agents_array="[]"
    
    # Convert tasks to agents
    local task_count=$(echo "$tasks" | jq 'length')
    for i in $(seq 0 $((task_count - 1))); do
        local task=$(echo "$tasks" | jq ".[$i]")
        local task_id=$(echo "$task" | jq -r '.id')
        local task_desc=$(echo "$task" | jq -r '.description')
        local task_dir=$(echo "$task" | jq -r '.directory')
        local deps=$(echo "$task" | jq -r '.dependencies[]? // empty' | tr '\n' ',' | sed 's/,$//')
        
        # Create worktree for this task
        local worktree_name="auto-cursor-${project_id}-${task_id}"
        local worktree_path="${WORKTREES_DIR}/${worktree_name}"
        
        # Create worktree if it doesn't exist
        if [ ! -d "$worktree_path" ]; then
            echo -e "${BLUE}Creating worktree for $task_id...${NC}"
            (
                cd "$project_path"
                git worktree add "$worktree_path" -b "auto-cursor/${task_id}" 2>/dev/null || {
                    # If worktree add fails, just create directory
                    mkdir -p "$worktree_path"
                    cp -r "$project_path"/* "$worktree_path"/ 2>/dev/null || true
                }
            )
        fi
        
        # Build dependencies array
        local deps_array="[]"
        if [ -n "$deps" ]; then
            deps_array=$(echo "$deps" | tr ',' '\n' | jq -R . | jq -s .)
        fi
        
        # Add agent to orchestration
        local agent_obj=$(cat << EOF
{
  "id": "$task_id",
  "directory": "$worktree_path",
  "initial_prompt": "$task_desc. Work in the $task_dir directory. Follow the project's coding standards and best practices.",
  "model": "auto",
  "dependencies": $deps_array,
  "run_qa": true,
  "qa_required": true
}
EOF
)
        agents_array=$(echo "$agents_array" | jq ". + [$agent_obj]")
    done
    
    # Create orchestration config
    cat > "$orchestration_file" << EOF
{
  "agents": $agents_array,
  "coordination": {
    "shared_vars": [],
    "qa_on_completion": true,
    "max_parallel": $parallel
  }
}
EOF
    
    echo -e "${BLUE}Max parallel tasks: $parallel${NC}"
    
    # REGRESSION_GUARD: Update task statuses - set to "pending" so scheduler can properly manage lifecycle
    # Status will be set to "running" by orchestrate-agents only after successful spawn
    # DO NOT set to "running" here - this was the root cause of the bug
    local updated_tasks=$(echo "$tasks" | jq 'map(.status = "pending" | .started = null | .attempts = null)')
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    
    # REGRESSION_GUARD: Validate that we didn't accidentally reintroduce the bug
    local regression_guard="${BASH_SOURCE[0]%/*}/regression-guard.sh"
    if [ -f "$regression_guard" ]; then
        if ! "$regression_guard" "$project_id" 2>/dev/null; then
            echo -e "${RED}REGRESSION_DETECTED: Tasks initialized as 'running' before spawn${NC}" >&2
            echo -e "${RED}This bug was fixed - check bin/auto-cursor line ~519${NC}" >&2
            exit 1
        fi
    fi
    
    # Store project metadata for cleanup tracking
    echo "$project_id" > "${project_dir}/.project-id"
    echo "$(date -Iseconds)" > "${project_dir}/.last-started"
    
    # CRITICAL: Export AUTO_CURSOR_MODE to ensure it's available to orchestrate-agents
    # This ensures assert_real_or_warn correctly detects REAL vs DRY mode
    export AUTO_CURSOR_MODE="${AUTO_CURSOR_MODE:-REAL}"
    
    # Start orchestration with automatic monitoring
    echo -e "${GREEN}Starting agents with orchestration...${NC}"
    if [ "$skip_qa" = "true" ]; then
        # Temporarily disable QA in orchestration
        local temp_orch=$(mktemp)
        jq '.coordination.qa_on_completion = false | .agents[].run_qa = false' "$orchestration_file" > "$temp_orch"
        orchestrate-agents start "$temp_orch"
        rm -f "$temp_orch"
    else
        orchestrate-agents start "$orchestration_file"
        
        # Start automatic monitoring in background to run QA on completion
        # Use nohup and redirect to log file so it persists
        local monitor_log="${project_dir}/monitor.log"
        (
            nohup orchestrate-agents monitor "$orchestration_file" > "$monitor_log" 2>&1
        ) &
        local monitor_pid=$!
        echo "$monitor_pid" > "${project_dir}/.monitor-pid"
        echo -e "${BLUE}Started automatic QA monitor (PID: $monitor_pid)${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Agents started with automatic QA monitoring${NC}"
    echo -e "${CYAN}Use 'auto-cursor status $project_id' to monitor progress${NC}"
    echo -e "${CYAN}Use 'auto-cursor board $project_id' for interactive view${NC}"
}

# Status display
# Get task debugging info (port, readiness, Playwright result, artifacts)
get_task_debug_info() {
    local project_id="$1"
    local task_id="$2"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    local info=""
    
    # Get port
    local port_file="${HOME}/.auto-cursor/server-state/${task_id}.port"
    if [ -f "$port_file" ]; then
        local port=$(cat "$port_file")
        info="${info}Port: $port | "
    fi
    
    # Get base_url
    if [ -n "$port" ]; then
        info="${info}Base URL: http://127.0.0.1:${port} | "
    fi
    
    # Get readiness result
    local proof_file="${HOME}/.auto-cursor/server-state/${task_id}.readiness-proof"
    if [ -f "$proof_file" ]; then
        info="${info}Readiness: READY | "
    elif [ -f "${HOME}/.auto-cursor/server-state/${task_id}.readiness-failure" ]; then
        info="${info}Readiness: FAILED | "
    fi
    
    # Get Playwright result from tasks.json
    local tasks_file="${project_dir}/tasks.json"
    if [ -f "$tasks_file" ]; then
        local playwright_result=$(jq -r ".[] | select(.id == \"$task_id\") | .last_qa_result // \"\" | select(. != \"\")" "$tasks_file" 2>/dev/null || echo "")
        if [ -n "$playwright_result" ]; then
            info="${info}Playwright: $playwright_result | "
        fi
        
        # Get flaky pass status
        local flaky_pass=$(jq -r ".[] | select(.id == \"$task_id\") | .flaky_pass // false" "$tasks_file" 2>/dev/null || echo "false")
        if [ "$flaky_pass" = "true" ]; then
            info="${info}Flaky: YES | "
        fi
    fi
    
    # Get artifact path
    local artifacts_dir="${project_dir}/artifacts/${task_id}"
    if [ -d "$artifacts_dir" ]; then
        local latest_attempt=$(ls -td "${artifacts_dir}"/attempt-* 2>/dev/null | head -1)
        if [ -n "$latest_attempt" ]; then
            info="${info}Artifacts: $latest_attempt"
        fi
    fi
    
    echo "$info"
}

show_status() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    local orchestration_file="${project_dir}/orchestration.json"
    
    # Load tasks
    local tasks=$(cat "$tasks_file" 2>/dev/null || echo "[]")
    
    # Try to save memory if tasks are completed (runs in background, doesn't block)
    save_plan_to_memory "$project_id" 2>/dev/null || true
    
    echo -e "${MAGENTA}=== Auto-Cursor Kanban Board: $project_id ===${NC}"
    echo ""
    
    # Group by status
    local pending=$(echo "$tasks" | jq '[.[] | select(.status == "pending")]')
    local running=$(echo "$tasks" | jq '[.[] | select(.status == "running")]')
    local qa_running=$(echo "$tasks" | jq '[.[] | select(.status == "qa_running")]')
    local completed=$(echo "$tasks" | jq '[.[] | select(.status == "completed" or .status == "qa_passed")]')
    local failed=$(echo "$tasks" | jq '[.[] | select(.status == "qa_failed" or .status == "failed")]')
    
    # Display columns
    printf "%-20s %-20s %-20s %-20s %-20s\n" "PENDING" "RUNNING" "QA" "COMPLETED" "FAILED"
    echo "────────────────────────────────────────────────────────────────────────────────────────────"
    
    local max_rows=$(echo "$tasks" | jq '[length, (.[] | select(.status == "pending") | length), (.[] | select(.status == "running") | length), (.[] | select(.status == "qa_running") | length), (.[] | select(.status == "completed" or .status == "qa_passed") | length), (.[] | select(.status == "qa_failed" or .status == "failed") | length)] | max')
    max_rows=${max_rows:-1}
    
    for i in $(seq 0 $((max_rows - 1))); do
        local p=$(echo "$pending" | jq -r ".[$i].id // empty" | cut -c1-18)
        local r=$(echo "$running" | jq -r ".[$i].id // empty" | cut -c1-18)
        local q=$(echo "$qa_running" | jq -r ".[$i].id // empty" | cut -c1-18)
        local c=$(echo "$completed" | jq -r ".[$i].id // empty" | cut -c1-18)
        local f=$(echo "$failed" | jq -r ".[$i].id // empty" | cut -c1-18)
        
        printf "%-20s %-20s %-20s %-20s %-20s\n" "${p:-}" "${r:-}" "${q:-}" "${c:-}" "${f:-}"
    done
    
    echo ""
    
    # Show orchestration status if running
    if [ -f "$orchestration_file" ]; then
        echo -e "${CYAN}Orchestration Status:${NC}"
        orchestrate-agents status 2>&1 | grep -v "No agents" || echo "  No active agents"
    fi
}

# Show tasks
show_tasks() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    
    echo -e "${MAGENTA}=== Tasks: $project_id ===${NC}"
    echo ""
    
    if [ ! -f "$tasks_file" ]; then
        echo "No tasks found. Create a plan first with: auto-cursor plan $project_id <goal>"
        return
    fi
    
    local tasks=$(cat "$tasks_file")
    local total=$(echo "$tasks" | jq 'length' 2>/dev/null || echo "0")
    if [ -z "$total" ] || [ "$total" = "null" ] || [ "$total" = "0" ]; then
        echo "No tasks found. Create a plan first with: auto-cursor plan $project_id <goal>"
        return
    fi
    
    local completed=$(echo "$tasks" | jq '[.[] | select(.status == "completed" or .status == "qa_passed")] | length' 2>/dev/null || echo "0")
    local progress=$((completed * 100 / total))
    
    echo -e "${CYAN}Progress: $completed/$total tasks completed ($progress%)${NC}"
    echo ""
    
    echo "$tasks" | jq -r '.[] | 
        "\(.id) - \(.description)
  Status: \(.status // "pending")
  Complexity: \(.complexity // "unknown")
  Directory: \(.directory // ".")
  Dependencies: \(.dependencies // [] | join(", ") // "none")
  Estimated: \(.estimated_hours // "unknown") hours"'
    
    # Add debugging info for running/failed tasks
    echo ""
    echo -e "${CYAN}Debugging Info:${NC}"
    echo "$tasks" | jq -r '.[] | select(.status == "running" or .status == "qa_running" or .status == "qa_failed" or .status == "failed") | .id' | while read -r task_id; do
        if [ -n "$task_id" ]; then
            echo ""
            echo -e "${YELLOW}Task: $task_id${NC}"
            local debug_info=$(get_task_debug_info "$project_id" "$task_id" "$project_dir")
            if [ -n "$debug_info" ]; then
                echo "  $debug_info"
            else
                echo "  (No debugging info available)"
            fi
        fi
    done
}

# Show agent logs
show_logs() {
    local project_id="$1"
    local task_id="${2:-all}"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    if [ "$task_id" = "all" ]; then
        echo -e "${CYAN}=== All Agent Logs: $project_id ===${NC}"
        echo ""
        
        local tasks=$(cat "${project_dir}/tasks.json" 2>/dev/null || echo "[]")
        local task_ids=$(echo "$tasks" | jq -r '.[].id')
        
        for tid in $task_ids; do
            echo -e "${MAGENTA}--- Task: $tid ---${NC}"
            orchestrate-agents logs "$tid" false 2>/dev/null || echo "  No logs available"
            echo ""
        done
    else
        echo -e "${CYAN}=== Logs for $task_id ===${NC}"
        echo ""
        
        # Show debugging info
        local debug_info=$(get_task_debug_info "$project_id" "$task_id" "$project_dir")
        if [ -n "$debug_info" ]; then
            echo -e "${YELLOW}Debugging Info:${NC}"
            echo "  $debug_info"
            echo ""
        fi
        
        # Show server log (last 20 lines)
        local server_log="${HOME}/.auto-cursor/server-state/${task_id}.server.log"
        if [ -f "$server_log" ]; then
            echo -e "${CYAN}Server Log (last 20 lines):${NC}"
            tail -20 "$server_log" | sed 's/^/  /'
            echo ""
        fi
        
        # Show Playwright output (last 30 lines)
        local qa_log="/tmp/cursor-agents/qa/${task_id}.log"
        if [ -f "$qa_log" ]; then
            echo -e "${CYAN}Playwright/QA Log (last 30 lines):${NC}"
            tail -30 "$qa_log" | sed 's/^/  /'
            echo ""
        fi
        
        # Show artifact path
        local artifacts_dir="${project_dir}/artifacts/${task_id}"
        if [ -d "$artifacts_dir" ]; then
            local latest_attempt=$(ls -td "${artifacts_dir}"/attempt-* 2>/dev/null | head -1)
            if [ -n "$latest_attempt" ]; then
                echo -e "${CYAN}Artifacts:${NC}"
                echo "  Path: $latest_attempt"
                if [ -f "${latest_attempt}/manifest.json" ]; then
                    echo "  Manifest: ${latest_attempt}/manifest.json"
                    echo "  Contents:"
                    jq -r '.artifacts | to_entries[] | "    \(.key): \(.value)"' "${latest_attempt}/manifest.json" 2>/dev/null || echo "    (Unable to parse manifest)"
                fi
                echo ""
                echo "  To view Playwright report:"
                echo "    cd $latest_attempt/playwright-report && python3 -m http.server 8080"
                echo "  To view trace:"
                echo "    npx playwright show-trace $latest_attempt/trace.zip"
                echo ""
            fi
        fi
        
        # Show orchestrate-agents logs
        orchestrate-agents logs "$task_id" false 2>/dev/null || {
            echo -e "${YELLOW}No agent logs found. Agent may not be running.${NC}"
            echo "Check status with: auto-cursor status $project_id"
        }
    fi
}

# Retry failed task
retry_task() {
    local project_id="$1"
    local task_id="${2:-all}"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    local tasks=$(cat "$tasks_file")
    
    if [ "$task_id" = "all" ]; then
        local failed_tasks=$(echo "$tasks" | jq -r '.[] | select(.status == "qa_failed" or .status == "failed") | .id')
        
        if [ -z "$failed_tasks" ]; then
            echo -e "${YELLOW}No failed tasks to retry${NC}"
            return
        fi
        
        echo -e "${CYAN}Retrying all failed tasks...${NC}"
        for tid in $failed_tasks; do
            retry_single_task "$project_id" "$tid" "$tasks_file"
        done
    else
        retry_single_task "$project_id" "$task_id" "$tasks_file"
    fi
}

retry_single_task() {
    local project_id="$1"
    local task_id="$2"
    local tasks_file="$3"
    
    local task=$(cat "$tasks_file" | jq ".[] | select(.id == \"$task_id\")")
    
    if [ -z "$task" ]; then
        echo -e "${RED}Error: Task not found: $task_id${NC}" >&2
        return
    fi
    
    local status=$(echo "$task" | jq -r '.status')
    if [ "$status" != "qa_failed" ] && [ "$status" != "failed" ]; then
        echo -e "${YELLOW}Task $task_id is not in failed state (current: $status)${NC}"
        return
    fi
    
    echo -e "${CYAN}Retrying task: $task_id${NC}"
    
    # Reset task status
    local updated_tasks=$(cat "$tasks_file" | jq "map(if .id == \"$task_id\" then .status = \"pending\" | .retry_count = ((.retry_count // 0) + 1) else . end)")
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    
    # Restart execution for this task
    echo -e "${GREEN}Task $task_id reset to pending. Run 'auto-cursor start $project_id' to retry.${NC}"
}

# Build website from business brief
build_website() {
    local target_path="$1"
    local business_brief="$2"
    local parallel="${3:-3}"  # Accept parallel value (default 3)
    
    # Validate target path (parent directory must exist)
    local parent_dir=$(dirname "$target_path")
    if [ ! -d "$parent_dir" ]; then
        echo -e "${RED}Error: Parent directory does not exist: $parent_dir${NC}" >&2
        exit 1
    fi
    
    # Reject unsafe paths
    if echo "$target_path" | grep -qE "(\.\.|/tmp|/var/tmp)"; then
        echo -e "${YELLOW}Warning: Target path contains potentially unsafe elements${NC}" >&2
    fi
    
    # Create target directory if it doesn't exist
    if [ ! -d "$target_path" ]; then
        mkdir -p "$target_path"
        echo -e "${GREEN}Created target directory: $target_path${NC}"
    fi
    
    # Generate spec from brief
    local brief_to_spec="${BASH_SOURCE[0]%/*}/brief-to-spec"
    if [ ! -f "$brief_to_spec" ]; then
        echo -e "${RED}Error: brief-to-spec utility not found${NC}" >&2
        exit 1
    fi
    
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo -e "${CYAN}Auto-Cursor Website Builder${NC}"
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""
    echo -e "${BLUE}Business Brief:${NC}"
    echo "  $business_brief"
    echo ""
    
    echo -e "${BLUE}Generating website specification...${NC}"
    local spec_json=$("$brief_to_spec" "$business_brief")
    
    if [ -z "$spec_json" ] || ! echo "$spec_json" | jq '.' >/dev/null 2>&1; then
        echo -e "${RED}Error: Failed to generate spec from brief${NC}" >&2
        exit 1
    fi
    
    # Extract spec details
    local business_name=$(echo "$spec_json" | jq -r '.business_name')
    local business_type=$(echo "$spec_json" | jq -r '.business_type')
    local pages=$(echo "$spec_json" | jq -r '.pages | join(", ")')
    local cta=$(echo "$spec_json" | jq -r '.cta')
    local location=$(echo "$spec_json" | jq -r '.location // ""')
    
    # Print spec
    echo -e "${GREEN}✓ Specification generated${NC}"
    echo ""
    echo -e "${CYAN}Website Specification:${NC}"
    echo "  Business: $business_name${location:+ ($location)}"
    echo "  Type: $business_type"
    echo "  Pages: $pages"
    echo "  Primary CTA: $cta"
    echo "  Contact Form: Required (local API route)"
    echo "  Features: Responsive, Accessibility, SEO, Playwright Tests"
    echo ""
    echo -e "${BLUE}Starting website build...${NC}"
    echo ""
    
    # Convert spec to goal string for planner
    local goal="Build a marketing website for $business_name"
    if [ -n "$location" ]; then
        goal="$goal in $location"
    fi
    goal="$goal. "
    goal="${goal}Pages: $pages. "
    goal="${goal}Requirements: responsive navigation and footer, clean modern layout. "
    goal="${goal}Contact page must submit to a local API endpoint and show a success message. "
    goal="${goal}Add Playwright tests that verify navigation, form submit success, and Home CTA visibility. "
    goal="${goal}Primary CTA: \"$cta\". "
    goal="${goal}Post-merge QA must pass."
    
    # Generate project ID from target path
    local project_id=$(basename "$target_path" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g')
    if [ -z "$project_id" ] || [ "$project_id" = "-" ]; then
        project_id="website-$(date +%s)"
    fi
    
    # Call golden-path run (use run-golden-path script)
    local run_script="${BASH_SOURCE[0]%/*}/run-golden-path"
    if [ ! -f "$run_script" ]; then
        echo -e "${RED}Error: run-golden-path utility not found${NC}" >&2
        exit 1
    fi
    
    # Check for --parallel flag (forward to run-golden-path)
    local parallel_val="3"
    # website command doesn't take --parallel directly, but we can extract from environment or use default
    # For now, use default 3 (can be enhanced later)
    
    # Run golden path (capture exit code)
    local run_exit=0
    "$run_script" "$target_path" "$goal" "$project_id" "$parallel" || run_exit=$?
    
    # Print deliverables summary (regardless of success/failure)
    echo ""
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    if [ $run_exit -eq 0 ]; then
        echo -e "${CYAN}Website Build Complete${NC}"
    else
        echo -e "${CYAN}Website Build Summary${NC}"
    fi
    echo -e "${CYAN}════════════════════════════════════════${NC}"
    echo ""
    echo -e "${GREEN}Deliverables:${NC}"
    echo "  Target Directory: $target_path"
    echo "  Project ID: $project_id"
    echo ""
    echo -e "${CYAN}Pages Created:${NC}"
    echo "$spec_json" | jq -r '.pages[]' | while read -r page; do
        echo "  - $page"
    done
    echo ""
    echo -e "${CYAN}How to Run:${NC}"
    echo "  1. Development server:"
    echo "     cd $target_path"
    echo "     npm run dev"
    echo ""
    echo "  2. Run Playwright tests:"
    echo "     cd $target_path"
    echo "     npx playwright test"
    echo ""
    echo "  3. Build for production:"
    echo "     cd $target_path"
    echo "     npm run build"
    echo ""
    echo -e "${CYAN}Artifacts Location:${NC}"
    echo "  If Playwright tests fail, artifacts are stored at:"
    echo "  ~/.auto-cursor/projects/$project_id/artifacts/<task-id>/<attempt-N>-<timestamp>/"
    echo ""
    
    if [ $run_exit -eq 0 ]; then
        echo -e "${GREEN}✓ Website ready for deployment${NC}"
    else
        echo -e "${YELLOW}⚠ Build completed with issues. Check logs for details.${NC}"
    fi
    
    return $run_exit
}

# Show diff before merge
show_diff() {
    local project_id="$1"
    local task_id="$2"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    local worktree_name="auto-cursor-${project_id}-${task_id}"
    local worktree_path="${WORKTREES_DIR}/${worktree_name}"
    
    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}Error: Worktree not found for task: $task_id${NC}" >&2
        return
    fi
    
    echo -e "${CYAN}=== Diff for $task_id ===${NC}"
    echo ""
    
    (
        cd "$worktree_path"
        if git rev-parse --git-dir >/dev/null 2>&1; then
            git diff main...HEAD 2>/dev/null || git diff HEAD 2>/dev/null || echo "No changes to show"
        else
            # If not a git worktree, show file changes
            echo "Worktree changes:"
            diff -r "$project_path" "$worktree_path" 2>/dev/null | head -50 || echo "No differences found"
        fi
    )
}

# Review worktree changes
review_worktree() {
    local project_id="$1"
    local task_id="${2:-all}"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    
    if [ "$task_id" = "all" ]; then
        local tasks=$(cat "${project_dir}/tasks.json" 2>/dev/null || echo "[]")
        local task_ids=$(echo "$tasks" | jq -r '.[].id')
        
        for tid in $task_ids; do
            echo -e "${MAGENTA}=== Reviewing: $tid ===${NC}"
            show_diff "$project_id" "$tid"
            echo ""
        done
    else
        show_diff "$project_id" "$task_id"
    fi
}

# Discard worktree without merging
discard_worktree() {
    local project_id="$1"
    local task_id="${2:-all}"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    local tasks_file="${project_dir}/tasks.json"
    
    if [ "$task_id" = "all" ]; then
        local tasks=$(cat "$tasks_file" 2>/dev/null || echo "[]")
        local task_ids=$(echo "$tasks" | jq -r '.[].id')
        
        echo -e "${YELLOW}Discarding all worktrees for $project_id${NC}"
        for tid in $task_ids; do
            discard_single_worktree "$project_id" "$tid" "$project_path"
        done
    else
        discard_single_worktree "$project_id" "$task_id" "$project_path"
    fi
}

discard_single_worktree() {
    local project_id="$1"
    local task_id="$2"
    local project_path="$3"
    
    local worktree_name="auto-cursor-${project_id}-${task_id}"
    local worktree_path="${WORKTREES_DIR}/${worktree_name}"
    
    if [ ! -d "$worktree_path" ]; then
        echo -e "${YELLOW}Worktree not found for $task_id, skipping...${NC}"
        return
    fi
    
    echo -e "${CYAN}Discarding worktree: $task_id${NC}"
    
    # Stop agent if running
    orchestrate-agents stop "$task_id" 2>/dev/null || true
    
    # Remove worktree
    (
        cd "$project_path"
        if git worktree list | grep -q "$worktree_path"; then
            git worktree remove "$worktree_path" --force 2>/dev/null || true
        fi
    )
    
    # Remove directory
    rm -rf "$worktree_path" 2>/dev/null || true
    
    # Remove git branch
    (
        cd "$project_path"
        git branch -D "auto-cursor/${task_id}" 2>/dev/null || true
    )
    
    echo -e "${GREEN}Discarded $task_id${NC}"
}

# Cleanup terminal-state worktrees for a project
# Safety: Never delete non-terminal worktrees. Never kill processes.
cleanup_terminal_worktrees() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    if [ ! -f "$tasks_file" ]; then
        echo -e "${YELLOW}No tasks found for project: $project_id${NC}"
        exit 0
    fi
    
    # Find terminal-state tasks (completed or failed)
    local terminal_tasks=$(jq -r '.[] | select(.status == "completed" or .status == "failed") | .id' "$tasks_file" 2>/dev/null || echo "")
    
    if [ -z "$terminal_tasks" ]; then
        echo -e "${YELLOW}No terminal-state tasks found for project: $project_id${NC}"
        exit 0
    fi
    
    # Collect worktrees to clean
    local worktrees_to_clean=""
    local project_path=$(jq -r '.path' "${project_dir}/config.json" 2>/dev/null || echo "")
    
    echo -e "${BLUE}Terminal-state worktrees for project: $project_id${NC}"
    echo ""
    
    for task_id in $terminal_tasks; do
        local worktree_name="auto-cursor-${project_id}-${task_id}"
        local worktree_path="${WORKTREES_DIR}/${worktree_name}"
        
        if [ -d "$worktree_path" ]; then
            local task_status=$(jq -r ".[] | select(.id == \"$task_id\") | .status" "$tasks_file" 2>/dev/null || echo "unknown")
            echo -e "  ${CYAN}•${NC} $task_id (status: $task_status)"
            echo -e "    ${YELLOW}→${NC} $worktree_path"
            worktrees_to_clean="${worktrees_to_clean}${task_id} "
        fi
    done
    
    if [ -z "$worktrees_to_clean" ]; then
        echo -e "${YELLOW}No worktrees found for terminal-state tasks${NC}"
        exit 0
    fi
    
    echo ""
    echo -e "${YELLOW}This will remove the worktrees listed above.${NC}"
    echo -e "${YELLOW}Continue? (yes/no): ${NC}"
    read -r confirmation
    
    if [ "$confirmation" != "yes" ]; then
        echo -e "${YELLOW}Cancelled${NC}"
        exit 0
    fi
    
    # Clean up worktrees
    echo ""
    echo -e "${BLUE}Cleaning up worktrees...${NC}"
    
    for task_id in $worktrees_to_clean; do
        discard_single_worktree "$project_id" "$task_id" "$project_path"
    done
    
    echo ""
    echo -e "${GREEN}Cleanup complete${NC}"
}

# Continue interrupted execution
# Cleanup stale PIDs and locks for a project
cleanup_stale_resources() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    echo -e "${BLUE}Cleaning up stale resources for $project_id...${NC}"
    
    # Get all task IDs from tasks.json
    local tasks_file="${project_dir}/tasks.json"
    if [ ! -f "$tasks_file" ]; then
        return 0
    fi
    
    local task_ids=$(jq -r '.[].id' "$tasks_file" 2>/dev/null || echo "")
    
    for task_id in $task_ids; do
        # Check server PIDs
        local pid_file="${HOME}/.auto-cursor/server-state/${task_id}.pid"
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file" 2>/dev/null || echo "")
            if [ -n "$pid" ] && [ "$pid" != "0" ]; then
                if ! kill -0 "$pid" 2>/dev/null; then
                    echo "  Removing stale server PID: $pid (task: $task_id)"
                    rm -f "$pid_file"
                fi
            fi
        fi
        
        # Check agent PIDs
        local agent_pid_file="/tmp/cursor-agents/pids/${task_id}.pid"
        if [ -f "$agent_pid_file" ]; then
            local pid=$(cat "$agent_pid_file" 2>/dev/null || echo "")
            if [ -n "$pid" ] && [ "$pid" != "0" ]; then
                if ! kill -0 "$pid" 2>/dev/null; then
                    echo "  Removing stale agent PID: $pid (task: $task_id)"
                    rm -f "$agent_pid_file"
                fi
            fi
        fi
        
        # Check locks (stale if older than 1 hour)
        local lock_file="/tmp/cursor-agents/pids/${task_id}.lock"
        if [ -f "$lock_file" ]; then
            local lock_age=$(($(date +%s) - $(stat -c %Y "$lock_file" 2>/dev/null || echo "0")))
            if [ $lock_age -gt 3600 ]; then
                echo "  Removing stale lock: $lock_file (age: ${lock_age}s)"
                rm -f "$lock_file"
            fi
        fi
    done
    
    echo -e "${GREEN}✓ Cleanup complete${NC}"
}

continue_execution() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    # Auto-migrate state
    auto-cursor-migrate "$project_id" >/dev/null 2>&1 || true
    
    # Cleanup stale resources
    cleanup_stale_resources "$project_id"
    
    local orchestration_file="${project_dir}/orchestration.json"
    local tasks_file="${project_dir}/tasks.json"
    
    if [ ! -f "$orchestration_file" ]; then
        echo -e "${YELLOW}No active orchestration found. Use 'auto-cursor start $project_id' to begin.${NC}"
        return
    fi
    
    echo -e "${CYAN}Continuing execution for $project_id...${NC}"
    echo ""
    
    # Verify worktrees exist (recreate if missing safely)
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    local tasks=$(cat "$tasks_file" 2>/dev/null || echo "[]")
    
    echo -e "${BLUE}Verifying worktrees...${NC}"
    local task_count=$(echo "$tasks" | jq 'length' 2>/dev/null || echo "0")
    for i in $(seq 0 $((task_count - 1))); do
        local task_id=$(echo "$tasks" | jq -r ".[$i].id")
        local worktree_name="auto-cursor-${project_id}-${task_id}"
        local worktree_path="${WORKTREES_DIR}/${worktree_name}"
        
        if [ ! -d "$worktree_path" ]; then
            echo "  Recreating worktree for $task_id..."
            (
                cd "$project_path"
                git worktree add "$worktree_path" -b "auto-cursor/${task_id}" 2>/dev/null || {
                    mkdir -p "$worktree_path"
                    cp -r "$project_path"/* "$worktree_path"/ 2>/dev/null || true
                }
            )
        fi
    done
    
    # Check for RUNNING tasks and verify PIDs
    echo -e "${BLUE}Checking task statuses...${NC}"
    local updated_tasks=$(echo "$tasks" | jq -c '.[]' | while IFS= read -r task; do
        local task_id=$(echo "$task" | jq -r '.id')
        local status=$(echo "$task" | jq -r '.status')
        
        if [ "$status" = "running" ]; then
            # Check if PID exists and process is alive
            local pid_file="/tmp/cursor-agents/pids/${task_id}.pid"
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file" 2>/dev/null || echo "")
                if [ -n "$pid" ] && [ "$pid" != "0" ] && kill -0 "$pid" 2>/dev/null; then
                    # Process is alive, keep as RUNNING
                    echo "$task" | jq '.status = "running"'
                else
                    # PID missing/dead, mark as FAILED and requeue
                    echo "  Task $task_id: PID dead, marking as failed and requeuing..."
                    echo "$task" | jq '.status = "pending" | .retry_count = ((.retry_count // 0) + 1)'
                fi
            else
                # No PID file, mark as pending
                echo "  Task $task_id: No PID found, marking as pending..."
                echo "$task" | jq '.status = "pending"'
            fi
        else
            echo "$task"
        fi
    done | jq -s '.')
    
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    
    # Resume scheduler
    echo -e "${GREEN}Resuming execution...${NC}"
    orchestrate-agents start "$orchestration_file" &
    local start_pid=$!
    
    # Start monitor in background
    (
        nohup orchestrate-agents monitor "$orchestration_file" > "${project_dir}/monitor.log" 2>&1
    ) &
    local monitor_pid=$!
    echo "$monitor_pid" > "${project_dir}/.monitor-pid"
    
    echo -e "${CYAN}Monitor started (PID: $monitor_pid)${NC}"
    echo -e "${CYAN}Use 'auto-cursor status $project_id' to monitor progress${NC}"
}

# Save successful plan to memory
save_plan_to_memory() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        return 1
    fi
    
    local memory_file="${project_dir}/memory.json"
    local tasks_file="${project_dir}/tasks.json"
    local plan_file="${project_dir}/plan.json"
    
    if [ ! -f "$tasks_file" ] || [ ! -f "$plan_file" ]; then
        return 1
    fi
    
    # Check if all tasks are completed successfully
    local tasks=$(cat "$tasks_file" 2>/dev/null || echo "[]")
    local all_completed=$(echo "$tasks" | jq '[.[] | select(.status == "completed" or .status == "qa_passed")] | length' 2>/dev/null || echo "0")
    local total_tasks=$(echo "$tasks" | jq 'length' 2>/dev/null || echo "0")
    
    # Only save if at least 80% of tasks completed successfully
    if [ "$all_completed" = "0" ] || [ "$total_tasks" = "0" ]; then
        return 0
    fi
    
    # Calculate success rate (using integer math)
    local success_rate=$((all_completed * 100 / total_tasks))
    if [ "$success_rate" -lt 80 ]; then
        return 0
    fi
    
    # Load existing memory
    local memory=$(cat "$memory_file" 2>/dev/null || echo "{}")
    
    # Extract patterns from successful tasks
    local successful_tasks=$(echo "$tasks" | jq '[.[] | select(.status == "completed" or .status == "qa_passed")]')
    local plan=$(cat "$plan_file" 2>/dev/null || echo "[]")
    
    # Extract common patterns
    local patterns=$(echo "$successful_tasks" | jq -r '[.[] | .description] | .[]' | grep -iE "(create|add|implement|build|setup|configure)" | head -5 | jq -R . | jq -s . 2>/dev/null || echo "[]")
    
    # Detect project type from directory structure
    local project_path=$(jq -r '.path' "${project_dir}/config.json" 2>/dev/null || echo "")
    local project_type=""
    if [ -n "$project_path" ] && [ -d "$project_path" ]; then
        if [ -f "$project_path/package.json" ]; then
            project_type="nodejs"
        elif [ -f "$project_path/requirements.txt" ] || [ -f "$project_path/pyproject.toml" ]; then
            project_type="python"
        elif [ -d "$project_path/src" ] && [ -f "$project_path/Cargo.toml" ]; then
            project_type="rust"
        elif [ -d "$project_path/backend" ] && [ -d "$project_path/frontend" ]; then
            project_type="fullstack"
        fi
    fi
    
    # Detect tech stack
    local tech_stack=$(echo "$plan" | jq -r '[.[] | .directory] | unique | .[]' | grep -E "(api|backend|frontend|ui|component)" | head -3 | jq -R . | jq -s . 2>/dev/null || echo "[]")
    
    # Update memory
    local updated_memory=$(echo "$memory" | jq --argjson patterns "$patterns" --argjson tech_stack "$tech_stack" --arg project_type "$project_type" '
        .successful_patterns = ((.successful_patterns // []) + $patterns | unique | .[0:10]) |
        .tech_stack = ((.tech_stack // []) + $tech_stack | unique) |
        .project_type = (if .project_type == "" or .project_type == null then $project_type else .project_type end) |
        .last_successful_build = now |
        .total_successful_builds = ((.total_successful_builds // 0) + 1)
    ' 2>/dev/null || echo "$memory")
    
    echo "$updated_memory" | jq '.' > "$memory_file" 2>/dev/null || true
}

# Show memory/insights
show_memory() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local memory_file="${project_dir}/memory.json"
    
    echo -e "${MAGENTA}=== Memory & Insights: $project_id ===${NC}"
    echo ""
    
    if [ -f "$memory_file" ]; then
        cat "$memory_file" | jq '.' 2>/dev/null || cat "$memory_file"
    else
        echo "No memory/insights stored yet"
    fi
}

# Start web interface
start_web_interface() {
    local port="${1:-8765}"
    
    # Find web server script - try multiple locations
    local web_server=""
    
    # Method 1: Relative to script location (if installed in repo)
    local script_dir=""
    if [ -f "${BASH_SOURCE[0]}" ]; then
        script_dir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
    else
        script_dir="$(cd "$(dirname "$0")" && pwd)"
    fi
    
    # Try relative to bin/ directory (repo structure)
    if [ -f "${script_dir}/../web/server.py" ]; then
        web_server="$(cd "${script_dir}/../web" && pwd)/server.py"
    # Try if we're in the repo root
    elif [ -f "web/server.py" ]; then
        web_server="$(pwd)/web/server.py"
    # Try common installation locations
    elif [ -f "$HOME/.local/share/auto-cursor/web/server.py" ]; then
        web_server="$HOME/.local/share/auto-cursor/web/server.py"
    elif [ -f "/usr/local/share/auto-cursor/web/server.py" ]; then
        web_server="/usr/local/share/auto-cursor/web/server.py"
    else
        # Try to find auto-cursor repo in common locations
        for search_dir in "$HOME" "/opt" "/usr/local"; do
            local found=$(find "$search_dir" -name "auto-cursor" -type d -path "*/auto-cursor" 2>/dev/null | head -1)
            if [ -n "$found" ] && [ -f "$found/web/server.py" ]; then
                web_server="$found/web/server.py"
                break
            fi
        done
    fi
    
    if [ -z "$web_server" ] || [ ! -f "$web_server" ]; then
        echo -e "${RED}Error: Web server script not found${NC}" >&2
        echo "Please ensure web/server.py exists in the auto-cursor repository" >&2
        echo "Current script location: $script_dir" >&2
        exit 1
    fi
    
    # Check if Flask is installed
    if ! python3 -c "import flask" 2>/dev/null; then
        echo -e "${YELLOW}Flask not found. Installing Flask...${NC}"
        pip3 install flask flask-cors --user 2>/dev/null || {
            echo -e "${RED}Error: Could not install Flask. Please install manually:${NC}" >&2
            echo "  pip3 install flask flask-cors" >&2
            exit 1
        }
    fi
    
    echo -e "${GREEN}Starting Auto-Cursor Web Interface...${NC}"
    echo -e "${CYAN}Server will start on: http://localhost:${port}${NC}"
    echo -e "${CYAN}Press Ctrl+C to stop${NC}"
    echo ""
    
    # Change to web directory for proper template/static resolution
    local web_dir=$(dirname "$web_server")
    cd "$web_dir"
    
    # Start server
    PORT="$port" python3 server.py
}

# Clean project
clean_project() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    local worktrees_dir="${WORKTREES_DIR}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    echo -e "${YELLOW}Cleaning up project: $project_id${NC}"
    
    # Stop only agents belonging to this project
    local orchestration_file="${project_dir}/orchestration.json"
    if [ -f "$orchestration_file" ]; then
        # Get agent IDs for this project
        local agent_ids=$(jq -r '.agents[].id' "$orchestration_file" 2>/dev/null || echo "")
        
        if [ -n "$agent_ids" ]; then
            echo -e "${BLUE}Stopping agents for project $project_id...${NC}"
            for agent_id in $agent_ids; do
                orchestrate-agents stop "$agent_id" 2>/dev/null || true
            done
        fi
    fi
    
    # Stop background monitor if running
    local monitor_pid_file="${project_dir}/.monitor-pid"
    if [ -f "$monitor_pid_file" ]; then
        local monitor_pid=$(cat "$monitor_pid_file" 2>/dev/null || echo "")
        if [ -n "$monitor_pid" ] && kill -0 "$monitor_pid" 2>/dev/null; then
            kill "$monitor_pid" 2>/dev/null || true
            echo -e "${BLUE}Stopped background monitor${NC}"
        fi
        rm -f "$monitor_pid_file"
    fi
    
    # Remove worktrees
    for worktree in "${worktrees_dir}"/auto-cursor-${project_id}-*; do
        if [ -d "$worktree" ]; then
            echo "Removing worktree: $(basename "$worktree")"
            rm -rf "$worktree"
        fi
    done
    
    # Clean up git branches
    local project_path=$(jq -r '.path' "${project_dir}/config.json")
    if [ -d "$project_path/.git" ]; then
        (
            cd "$project_path"
            git branch | grep "auto-cursor/" | xargs -r git branch -D 2>/dev/null || true
        )
    fi
    
    echo -e "${GREEN}Cleanup complete${NC}"
}

# Validate plan
validate_plan() {
    local project_id="$1"
    local auto_fix="${2:-false}"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    
    if [ ! -f "$tasks_file" ]; then
        echo -e "${RED}Error: No plan found. Create a plan first with: auto-cursor plan $project_id <goal>${NC}" >&2
        exit 1
    fi
    
    local task_length=$(cat "$tasks_file" | jq 'length' 2>/dev/null || echo "0")
    if [ -z "$task_length" ] || [ "$task_length" = "null" ] || [ "$task_length" = "0" ]; then
        echo -e "${RED}Error: No plan found. Create a plan first with: auto-cursor plan $project_id <goal>${NC}" >&2
        exit 1
    fi
    
    echo -e "${CYAN}=== Validating Plan: $project_id ===${NC}"
    echo ""
    
    local tasks=$(cat "$tasks_file")
    local errors=()
    local warnings=()
    
    # Check 1: Duplicate task IDs
    local duplicate_ids=$(echo "$tasks" | jq -r 'group_by(.id) | map(select(length > 1)) | .[][].id' 2>/dev/null || echo "")
    if [ -n "$duplicate_ids" ]; then
        errors+=("Duplicate task IDs: $(echo "$duplicate_ids" | tr '\n' ' ' | sed 's/ $//')")
    fi
    
    # Check 2: Missing required fields
    local missing_ids=$(echo "$tasks" | jq -r '.[] | select(.id == null or .id == "") | .id' 2>/dev/null || echo "")
    if [ -n "$missing_ids" ]; then
        errors+=("Tasks with missing IDs found")
    fi
    
    local missing_descriptions=$(echo "$tasks" | jq -r '.[] | select(.description == null or .description == "") | .id' 2>/dev/null || echo "")
    if [ -n "$missing_descriptions" ]; then
        errors+=("Tasks with missing descriptions: $(echo "$missing_descriptions" | tr '\n' ' ' | sed 's/ $//')")
    fi
    
    # Check 3: Circular dependencies
    local task_ids=$(echo "$tasks" | jq -r '.[].id')
    for task_id in $task_ids; do
        local deps=$(echo "$tasks" | jq -r ".[] | select(.id == \"$task_id\") | .dependencies[]?" 2>/dev/null || echo "")
        for dep in $deps; do
            # Check if dependency exists
            if ! echo "$tasks" | jq -e ".[] | select(.id == \"$dep\")" >/dev/null 2>&1; then
                warnings+=("Task '$task_id' depends on non-existent task '$dep'")
            fi
            
            # Check for circular dependency (simple check - direct cycles)
            local dep_deps=$(echo "$tasks" | jq -r ".[] | select(.id == \"$dep\") | .dependencies[]?" 2>/dev/null || echo "")
            if echo "$dep_deps" | grep -q "^${task_id}$"; then
                errors+=("Circular dependency detected: $task_id <-> $dep")
            fi
        done
    done
    
    # Check 4: Invalid complexity values
    local invalid_complexity=$(echo "$tasks" | jq -r '.[] | select(.complexity != null and .complexity != "simple" and .complexity != "medium" and .complexity != "complex") | "\(.id): \(.complexity)"' 2>/dev/null || echo "")
    if [ -n "$invalid_complexity" ]; then
        warnings+=("Invalid complexity values: $invalid_complexity")
    fi
    
    # Display results
    if [ ${#errors[@]} -eq 0 ] && [ ${#warnings[@]} -eq 0 ]; then
        echo -e "${GREEN}✅ Plan validation passed!${NC}"
        echo ""
        local task_count=$(echo "$tasks" | jq 'length')
        echo "  Tasks: $task_count"
        local total_hours=$(echo "$tasks" | jq '[.[] | .estimated_hours // 0] | add' 2>/dev/null || echo "0")
        if [ "$total_hours" != "0" ] && [ "$total_hours" != "null" ]; then
            echo "  Estimated time: ${total_hours} hours"
        fi
        return 0
    fi
    
    # Show errors
    if [ ${#errors[@]} -gt 0 ]; then
        echo -e "${RED}❌ Validation Errors:${NC}"
        for error in "${errors[@]}"; do
            echo "  • $error"
        done
        echo ""
    fi
    
    # Show warnings
    if [ ${#warnings[@]} -gt 0 ]; then
        echo -e "${YELLOW}⚠️  Validation Warnings:${NC}"
        for warning in "${warnings[@]}"; do
            echo "  • $warning"
        done
        echo ""
    fi
    
    # Auto-fix if requested
    if [ "$auto_fix" = "true" ] && [ ${#errors[@]} -gt 0 ]; then
        echo -e "${BLUE}Attempting to auto-fix errors...${NC}"
        # Basic auto-fix: remove duplicate IDs, fix missing fields
        # This is a simple implementation - could be enhanced
        echo -e "${YELLOW}Auto-fix not fully implemented yet. Please fix errors manually.${NC}"
    fi
    
    return 1
}

# Review plan
review_plan() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    
    if [ ! -f "$tasks_file" ]; then
        echo -e "${RED}Error: No plan found. Create a plan first with: auto-cursor plan $project_id <goal>${NC}" >&2
        exit 1
    fi
    
    local task_length=$(cat "$tasks_file" | jq 'length' 2>/dev/null || echo "0")
    if [ -z "$task_length" ] || [ "$task_length" = "null" ] || [ "$task_length" = "0" ]; then
        echo -e "${RED}Error: No plan found. Create a plan first with: auto-cursor plan $project_id <goal>${NC}" >&2
        exit 1
    fi
    
    echo -e "${MAGENTA}=== Plan Review: $project_id ===${NC}"
    echo ""
    
    local tasks=$(cat "$tasks_file")
    local task_count=$(echo "$tasks" | jq 'length')
    local total_hours=$(echo "$tasks" | jq '[.[] | .estimated_hours // 0] | add' 2>/dev/null || echo "0")
    
    echo -e "${CYAN}Summary:${NC}"
    echo "  Tasks: $task_count"
    if [ "$total_hours" != "0" ] && [ "$total_hours" != "null" ]; then
        echo "  Estimated time: ${total_hours} hours"
    fi
    echo ""
    
    echo -e "${CYAN}Tasks:${NC}"
    echo "$tasks" | jq -r '.[] | 
        "\(.id) - \(.description)
  Complexity: \(.complexity // "unknown")
  Directory: \(.directory // ".")
  Dependencies: \(.dependencies // [] | join(", ") // "none")
  Estimated: \(.estimated_hours // "unknown") hours
"'
    
    echo ""
    echo -e "${YELLOW}Use 'auto-cursor plan-edit $project_id' to edit this plan${NC}"
}

# Edit plan interactively
edit_plan() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    
    if [ ! -f "$tasks_file" ]; then
        echo -e "${RED}Error: No plan found. Create a plan first with: auto-cursor plan $project_id <goal>${NC}" >&2
        exit 1
    fi
    
    local task_length=$(cat "$tasks_file" | jq 'length' 2>/dev/null || echo "0")
    if [ -z "$task_length" ] || [ "$task_length" = "null" ] || [ "$task_length" = "0" ]; then
        echo -e "${RED}Error: No plan found. Create a plan first with: auto-cursor plan $project_id <goal>${NC}" >&2
        exit 1
    fi
    
    echo -e "${CYAN}=== Plan Editor: $project_id ===${NC}"
    echo ""
    echo "Commands:"
    echo "  add <description>     - Add new task"
    echo "  remove <task-id>       - Remove task"
    echo "  modify <task-id>       - Modify task"
    echo "  list                   - List all tasks"
    echo "  validate               - Validate plan"
    echo "  save                   - Save and exit"
    echo "  cancel                 - Cancel without saving"
    echo ""
    
    # For now, provide instructions - full interactive editor can be enhanced later
    echo -e "${YELLOW}Interactive editor coming soon.${NC}"
    echo "For now, use:"
    echo "  auto-cursor task-add $project_id <description>"
    echo "  auto-cursor task-remove $project_id <task-id>"
    echo "  auto-cursor task-modify $project_id <task-id>"
}

# Add task to plan
add_task() {
    local project_id="$1"
    shift
    local description="$*"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    local tasks=$(cat "$tasks_file")
    
    # Generate task ID from description
    local task_id=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | cut -c1-50)
    local task_num=$(echo "$tasks" | jq 'length')
    task_id="${task_id}-${task_num}"
    
    # Add task
    local new_task=$(cat << EOF
{
  "id": "$task_id",
  "description": "$description",
  "dependencies": [],
  "complexity": "medium",
  "directory": ".",
  "estimated_hours": 2,
  "status": "pending",
  "agent_id": null,
  "worktree": null,
  "created": $(date +%s),
  "started": null,
  "completed": null,
  "qa_status": null
}
EOF
)
    
    local updated_tasks=$(echo "$tasks" | jq ". + [$new_task]")
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    
    echo -e "${GREEN}Added task: $task_id${NC}"
    echo "  Description: $description"
}

# Remove task from plan
remove_task() {
    local project_id="$1"
    local task_id="$2"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    local tasks=$(cat "$tasks_file")
    
    # Check if task exists
    if ! echo "$tasks" | jq -e ".[] | select(.id == \"$task_id\")" >/dev/null 2>&1; then
        echo -e "${RED}Error: Task not found: $task_id${NC}" >&2
        exit 1
    fi
    
    # Remove task and update dependencies
    local updated_tasks=$(echo "$tasks" | jq "map(select(.id != \"$task_id\") | .dependencies = (.dependencies // [] | map(select(. != \"$task_id\"))))")
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    
    echo -e "${GREEN}Removed task: $task_id${NC}"
}

# Modify task in plan
modify_task() {
    local project_id="$1"
    local task_id="$2"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    local tasks=$(cat "$tasks_file")
    
    # Check if task exists
    if ! echo "$tasks" | jq -e ".[] | select(.id == \"$task_id\")" >/dev/null 2>&1; then
        echo -e "${RED}Error: Task not found: $task_id${NC}" >&2
        exit 1
    fi
    
    echo -e "${CYAN}Modifying task: $task_id${NC}"
    echo ""
    echo "Current task:"
    echo "$tasks" | jq ".[] | select(.id == \"$task_id\")"
    echo ""
    echo "Enter new values (press Enter to keep current):"
    
    read -p "Description: " new_desc
    read -p "Complexity (simple/medium/complex): " new_complexity
    read -p "Directory: " new_directory
    read -p "Estimated hours: " new_hours
    
    # Update task
    local updated_tasks=$(echo "$tasks" | jq "
        map(if .id == \"$task_id\" then
            . + {
                description: (if \"$new_desc\" != \"\" then \"$new_desc\" else .description end),
                complexity: (if \"$new_complexity\" != \"\" then \"$new_complexity\" else .complexity end),
                directory: (if \"$new_directory\" != \"\" then \"$new_directory\" else .directory end),
                estimated_hours: (if \"$new_hours\" != \"\" then ($new_hours | tonumber) else .estimated_hours end)
            }
        else . end)
    ")
    
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    echo -e "${GREEN}Updated task: $task_id${NC}"
}

# Pause task
pause_task() {
    local project_id="$1"
    local task_id="$2"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local worktree_name="auto-cursor-${project_id}-${task_id}"
    local worktree_path="${WORKTREES_DIR}/${worktree_name}"
    local pause_file="${worktree_path}/PAUSE"
    
    if [ ! -d "$worktree_path" ]; then
        echo -e "${YELLOW}Worktree not found. Task may not be running.${NC}"
        exit 1
    fi
    
    touch "$pause_file"
    echo -e "${GREEN}Paused task: $task_id${NC}"
    echo "  Pause file: $pause_file"
    echo "  To resume: rm $pause_file"
    echo "  To add instructions: echo 'instructions' > ${worktree_path}/HUMAN_INPUT.md"
}

# Cancel task
cancel_task() {
    local project_id="$1"
    local task_id="$2"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    echo -e "${YELLOW}Cancelling task: $task_id${NC}"
    
    # Stop agent
    orchestrate-agents stop "$task_id" 2>/dev/null || true
    
    # Update task status
    local tasks_file="${project_dir}/tasks.json"
    local tasks=$(cat "$tasks_file")
    local updated_tasks=$(echo "$tasks" | jq "map(if .id == \"$task_id\" then .status = \"failed\" else . end)")
    echo "$updated_tasks" | jq '.' > "$tasks_file"
    
    echo -e "${GREEN}Cancelled task: $task_id${NC}"
}

# Enhanced progress tracking
show_enhanced_progress() {
    local project_id="$1"
    local project_dir="${PROJECTS_DIR}/${project_id}"
    
    if [ ! -d "$project_dir" ]; then
        echo -e "${RED}Error: Project not found: $project_id${NC}" >&2
        exit 1
    fi
    
    local tasks_file="${project_dir}/tasks.json"
    local tasks=$(cat "$tasks_file" 2>/dev/null || echo "[]")
    
    local total=$(echo "$tasks" | jq 'length' 2>/dev/null || echo "0")
    if [ -z "$total" ] || [ "$total" = "null" ] || [ "$total" = "0" ]; then
        echo "No tasks found"
        return
    fi
    
    local completed=$(echo "$tasks" | jq '[.[] | select(.status == "completed" or .status == "qa_passed")] | length' 2>/dev/null || echo "0")
    local running=$(echo "$tasks" | jq '[.[] | select(.status == "running")] | length' 2>/dev/null || echo "0")
    local failed=$(echo "$tasks" | jq '[.[] | select(.status == "failed" or .status == "qa_failed")] | length' 2>/dev/null || echo "0")
    
    if [ "$total" = "0" ]; then
        echo "No tasks found"
        return
    fi
    
    local progress=$((completed * 100 / total))
    
    echo -e "${MAGENTA}=== Progress: $project_id ===${NC}"
    echo ""
    echo -e "${CYAN}Overall Progress:${NC}"
    echo "  Completed: $completed/$total ($progress%)"
    echo "  Running: $running"
    echo "  Failed: $failed"
    echo ""
    
    # Progress bar
    local bar_length=50
    local filled=$((progress * bar_length / 100))
    local bar=""
    for i in $(seq 1 $bar_length); do
        if [ $i -le $filled ]; then
            bar="${bar}█"
        else
            bar="${bar}░"
        fi
    done
    echo "  [$bar] $progress%"
    echo ""
    
    # Time estimates
    local total_estimated=$(echo "$tasks" | jq '[.[] | .estimated_hours // 0] | add' 2>/dev/null || echo "0")
    local completed_estimated=$(echo "$tasks" | jq '[.[] | select(.status == "completed" or .status == "qa_passed") | .estimated_hours // 0] | add' 2>/dev/null || echo "0")
    local remaining_estimated=$(echo "$total_estimated - $completed_estimated" | bc 2>/dev/null || echo "?")
    
    if [ "$total_estimated" != "0" ] && [ "$total_estimated" != "null" ]; then
        echo -e "${CYAN}Time Estimates:${NC}"
        echo "  Total estimated: ${total_estimated} hours"
        echo "  Completed: ${completed_estimated} hours"
        echo "  Remaining: ${remaining_estimated} hours"
        echo ""
    fi
    
    # Task breakdown
    echo -e "${CYAN}Task Status:${NC}"
    echo "$tasks" | jq -r '.[] | 
        "\(.id): \(.status // "pending")
  \(.description)
  Estimated: \(.estimated_hours // "unknown") hours
"'
}

# List projects
list_projects() {
    echo -e "${MAGENTA}=== Auto-Cursor Projects ===${NC}"
    echo ""
    
    if [ ! -d "$PROJECTS_DIR" ] || [ -z "$(ls -A $PROJECTS_DIR 2>/dev/null)" ]; then
        echo "No projects found"
        return
    fi
    
    for project_dir in "$PROJECTS_DIR"/*; do
        if [ -d "$project_dir" ] && [ -f "${project_dir}/config.json" ]; then
            local project_id=$(jq -r '.id' "${project_dir}/config.json")
            local project_path=$(jq -r '.path' "${project_dir}/config.json")
            local created=$(jq -r '.created' "${project_dir}/config.json")
            
            local task_count=$(jq 'length' "${project_dir}/tasks.json" 2>/dev/null || echo "0")
            local completed=$(jq '[.[] | select(.status == "completed" or .status == "qa_passed")] | length' "${project_dir}/tasks.json" 2>/dev/null || echo "0")
            
            echo -e "${GREEN}$project_id${NC}"
            echo "  Path: $project_path"
            echo "  Tasks: $completed/$task_count completed"
            echo "  Created: $created"
            echo ""
        fi
    done
}

# Main command dispatch
case "${1:-help}" in
    init)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project path required${NC}" >&2
            usage
            exit 1
        fi
        init_project "$2" "${3:-}"
        ;;
    plan)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        # Check if --interactive is used (goal not required)
        if echo "${@:3}" | grep -q -- "--interactive"; then
            plan_goal "$2" "${@:3}"
        elif [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Goal required (or use --interactive)${NC}" >&2
            usage
            exit 1
        else
            plan_goal "$2" "${@:3}"
        fi
        ;;
    start)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        # Check for blocked flags FIRST (before any other validation)
        _project_id="$2"
        _parallel="3"
        shift 2
        
        while [ $# -gt 0 ]; do
            case "$1" in
                --max-iterations|--skip-qa)
                    check_blocked_flag "$1"
                    # check_blocked_flag exits, but if it doesn't, continue
                    shift
                    ;;
                --parallel)
                    _parallel="$2"
                    shift 2
                    ;;
                *)
                    echo -e "${RED}Error: Unknown flag: $1${NC}" >&2
                    usage
                    exit 1
                    ;;
            esac
        done
        
        start_execution "$_project_id" "" "false" "$_parallel"
        ;;
    status)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        if [ "${3:-}" = "--detailed" ]; then
            show_enhanced_progress "$2"
        else
            show_status "$2"
        fi
        ;;
    validate)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        validate_plan "$2" "${3:-false}"
        ;;
    plan-review)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        review_plan "$2"
        ;;
    plan-edit)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        edit_plan "$2"
        ;;
    task-add)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project ID and task description required${NC}" >&2
            usage
            exit 1
        fi
        add_task "$2" "${@:3}"
        ;;
    task-remove)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project ID and task ID required${NC}" >&2
            usage
            exit 1
        fi
        remove_task "$2" "$3"
        ;;
    task-modify)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project ID and task ID required${NC}" >&2
            usage
            exit 1
        fi
        modify_task "$2" "$3"
        ;;
    pause)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project ID and task ID required${NC}" >&2
            usage
            exit 1
        fi
        pause_task "$2" "$3"
        ;;
    cancel)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project ID and task ID required${NC}" >&2
            usage
            exit 1
        fi
        cancel_task "$2" "$3"
        ;;
    board)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        # Interactive board (refresh every 2 seconds)
        while true; do
            clear
            show_status "$2"
            echo ""
            echo "Press Ctrl+C to exit"
            sleep 2
        done
        ;;
    list)
        list_projects
        ;;
    logs)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        if [ "${3:-}" = "--tail" ]; then
            tail-logs "$2" "${4:-all}"
        else
            show_logs "$2" "${3:-}"
        fi
        ;;
    summary)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        auto-cursor-summary "$2"
        ;;
    migrate)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        auto-cursor-migrate "$2"
        ;;
    retry)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        retry_task "$2" "${3:-}"
        ;;
    diff)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project ID and task ID required${NC}" >&2
            usage
            exit 1
        fi
        show_diff "$2" "$3"
        ;;
    tasks)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        show_tasks "$2"
        ;;
    merge)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        auto-cursor-merge "$2" "${3:-all}"
        ;;
    memory)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        show_memory "$2"
        ;;
    review)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        review_worktree "$2" "${3:-all}"
        ;;
    discard)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        discard_worktree "$2" "${3:-all}"
        ;;
    continue)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        continue_execution "$2"
        ;;
    clean)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        clean_project "$2"
        ;;
    cleanup)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        cleanup_terminal_worktrees "$2"
        ;;
    run)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Project path and goal required${NC}" >&2
            echo "Usage: auto-cursor run <project-path> <goal> [project-id]"
            exit 1
        fi
        # Check for context.json and extract parallel if specified
        _context_file="${2}/.auto-cursor/context.json"
        _context_parallel="3"
        if [ -f "$_context_file" ] && jq '.' "$_context_file" >/dev/null 2>&1; then
            _context_parallel=$(jq -r '.parallel // 3' "$_context_file" 2>/dev/null || echo "3")
        fi
        run-golden-path "$2" "$3" "${4:-}" "$_context_parallel"
        ;;
    website)
        if [ -z "${2:-}" ] || [ -z "${3:-}" ]; then
            echo -e "${RED}Error: Target path and business brief required${NC}" >&2
            echo "Usage: auto-cursor website <target-path> \"<business brief>\" [--parallel N]"
            exit 1
        fi
        _target_path="$2"
        _business_brief="$3"
        _parallel_val="3"
        shift 3  # Remove website, target_path, brief
        # Parse --parallel if provided
        while [ $# -gt 0 ]; do
            case "$1" in
                --parallel)
                    _parallel_val="$2"
                    shift 2
                    ;;
                *)
                    shift
                    ;;
            esac
        done
        build_website "$_target_path" "$_business_brief" "$_parallel_val"
        ;;
    contracts)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        contract-enforcer "$2"
        ;;
    trace-summary)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        trace-summary "$2"
        ;;
    progress)
        if [ -z "${2:-}" ]; then
            echo -e "${RED}Error: Project ID required${NC}" >&2
            usage
            exit 1
        fi
        auto-cursor-progress "$2"
        ;;
    upgrade-check)
        upgrade-check
        ;;
    doctor)
        auto-cursor-doctor
        ;;
    version|--version|-v)
        echo "auto-cursor version $VERSION"
        exit 0
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}" >&2
        echo ""
        usage
        exit 1
        ;;
esac
